"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelMessageWriter = exports.ChannelMessageReader = void 0;
exports.createChannelConnection = createChannelConnection;
/********************************************************************************
 * Copyright (c) 2022-2024 STMicroelectronics and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const core_1 = require("@theia/core");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
// Temporary fix/workaround to enable comparability with Theia >=1.27 until https://github.com/eclipse-theia/theia/issues/11405 is resolved
/**
 * A `vscode-jsonrpc` {@link MessageReader} that reads messages from an underlying {@link Channel}.
 */
class ChannelMessageReader extends vscode_jsonrpc_1.AbstractMessageReader {
    constructor(channel) {
        super();
        this.channel = channel;
        this.onMessageEmitter = new core_1.Emitter();
        this.toDispose = new core_1.DisposableCollection();
        this.toDispose.push(this.onMessageEmitter);
        this.toDispose.push(channel.onMessage(data => this.handleMessage(data)));
        this.toDispose.push(channel.onClose(() => this.fireClose()));
    }
    handleMessage(msgProvider) {
        const buffer = msgProvider().readBytes();
        const message = JSON.parse(new TextDecoder().decode(buffer));
        this.onMessageEmitter.fire(message);
    }
    dispose() {
        super.dispose();
        this.toDispose.dispose();
    }
    listen(callback) {
        return this.onMessageEmitter.event(callback);
    }
}
exports.ChannelMessageReader = ChannelMessageReader;
/**
 * A `vscode-jsonrpc` {@link MessageWriter} that writes messages to an underlying {@link Channel}.
 */
class ChannelMessageWriter extends vscode_jsonrpc_1.AbstractMessageWriter {
    constructor(channel) {
        super();
        this.channel = channel;
        this.toDispose = channel.onClose(() => this.fireClose());
    }
    async write(msg) {
        const writeBuffer = this.channel.getWriteBuffer();
        writeBuffer.writeBytes(Buffer.from(JSON.stringify(msg, undefined, 0)));
        writeBuffer.commit();
    }
    end() {
        this.dispose();
    }
    dispose() {
        super.dispose();
        this.toDispose.dispose();
    }
}
exports.ChannelMessageWriter = ChannelMessageWriter;
/**
 * Create a `vscode-jsonrpc` {@link MessageConnection} on top of a given {@link Channel}.
 */
function createChannelConnection(channel, logger) {
    const reader = new ChannelMessageReader(channel);
    const writer = new ChannelMessageWriter(channel);
    return (0, vscode_jsonrpc_1.createMessageConnection)(reader, writer, logger);
}
//# sourceMappingURL=channel-connection.js.map