"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLSPSaveable = void 0;
/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const client_1 = require("@eclipse-glsp/client");
const core_1 = require("@theia/core");
const common_1 = require("../../common");
/**
 * The default {@link Saveable} implementation of the `GLSPDiagramWidget`.
 * Since Theia 1.50.0, handling the autosave functionality is done by a central `SaveableService` and is no longer the responsibility of the
 * {@link Saveable} itself. This implementation includes a compatibility layer for both the old saveable implementation prior
 * to Theia 1.50.0 and the new saveable implementation.
 * When using a Theia version >= 1.50.0, the autosave functionality is limited to the `afterDelay` strategy.
 * Other autosave types (`onWindowChange` | `onFocusChange`) are not supported. If the `autoSaveType` is set to an unsupported value, the
 * `afterDelay` save strategy will be used.
 */
class GLSPSaveable {
    get onDirtyChanged() {
        return this.onDirtyChangedEmitter.event;
    }
    get onContentChanged() {
        return this.onContentChangedEmitter.event;
    }
    constructor(actionDispatcher, editorContextService) {
        this.actionDispatcher = actionDispatcher;
        this.editorContextService = editorContextService;
        this.toDispose = new core_1.DisposableCollection();
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onContentChangedEmitter = new core_1.Emitter();
        // The timeout in ms after which a pending save operation will be rejected if the server does not respond with a save confirmation
        // i.e dirty state change
        this.saveTimeout = 2000;
        // Compatibility layer for the old saveable implementation prior to Theia 1.50.0
        this.compatibilityLayerEnabled = (0, common_1.satisfiesTheiaVersion)('<1.50.0');
        this._autoSave = 'off';
        this.autoSaveDelay = 500;
        this.autoSaveJobs = new core_1.DisposableCollection();
        this.toDispose.pushAll([
            this.editorContextService.onDirtyStateChanged(change => this.handleDirtyStateChange(change)),
            this.onDirtyChangedEmitter,
            this.autoSaveJobs
        ]);
    }
    handleDirtyStateChange(change) {
        this.onDirtyChangedEmitter.fire(undefined);
        if (change.reason === 'save' && this.pendingSave) {
            this.pendingSave.resolve();
        }
        if (change.isDirty) {
            this.onContentChangedEmitter.fire(undefined);
            this.scheduleAutoSave();
        }
    }
    /**
     * Saves the current diagram by dispatching a `SaveModelAction` to the GLSP server.
     * The save operation is asynchronous and the method returns a promise that resolves once the save operation is completed.
     * or is rejected if the {@link saveTimeout} is reached before the server responds with a save confirmation.
     * Note: if the diagram is currently not dirty this is a no-op and no save action is dispatched.
     * @returns A promise that resolves once the save client-server roundtrip is completed i.e.
     * the server has responded with a save confirmation in the form of `SetDirtyStateAction`
     */
    save() {
        if (this.editorContextService.isDirty) {
            this.actionDispatcher.dispatch(client_1.SaveModelAction.create());
            this.pendingSave = new client_1.Deferred();
            const savePromise = this.pendingSave.promise.then(() => (this.pendingSave = undefined));
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => {
                if (this.pendingSave && this.pendingSave.state === 'unresolved') {
                    this.pendingSave.resolve();
                    this.pendingSave = undefined;
                    reject(new Error('Save operation timed out'));
                }
            }, this.saveTimeout));
            return Promise.race([savePromise, timeoutPromise]).catch(error => {
                this.pendingSave = undefined;
                throw error;
            });
        }
        return Promise.resolve();
    }
    get dirty() {
        if (this.pendingSave) {
            return false;
        }
        return this.editorContextService.isDirty;
    }
    dispose() {
        this.toDispose.dispose();
    }
    doAutoSave() {
        if (this.shouldAutoSave) {
            this.save();
        }
    }
    get shouldAutoSave() {
        return this.compatibilityLayerEnabled && this.dirty && this.autoSave !== 'off';
    }
    set autoSave(autoSave) {
        this._autoSave = autoSave;
        if (this.shouldAutoSave) {
            this.scheduleAutoSave();
        }
        else {
            this.autoSaveJobs.dispose();
        }
    }
    get autoSave() {
        return this._autoSave;
    }
    scheduleAutoSave() {
        if (this.shouldAutoSave) {
            this.autoSaveJobs.dispose();
            const autoSaveJob = window.setTimeout(() => this.doAutoSave(), this.autoSaveDelay);
            const disposableAutoSaveJob = core_1.Disposable.create(() => window.clearTimeout(autoSaveJob));
            this.autoSaveJobs.push(disposableAutoSaveJob);
        }
    }
}
exports.GLSPSaveable = GLSPSaveable;
//# sourceMappingURL=glsp-saveable.js.map