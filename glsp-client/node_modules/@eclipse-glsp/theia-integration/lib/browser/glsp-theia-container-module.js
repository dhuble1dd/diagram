"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLSPTheiaFrontendModule = void 0;
/********************************************************************************
 * Copyright (c) 2021-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const client_1 = require("@eclipse-glsp/client");
const inversify_1 = require("@theia/core/shared/inversify");
const _1 = require(".");
const glsp_diagram_language_1 = require("../common/glsp-diagram-language");
const copy_paste_context_menu_contribution_1 = require("./copy-paste-context-menu-contribution");
const diagram_widget_factory_1 = require("./diagram/diagram-widget-factory");
const glsp_diagram_manager_1 = require("./diagram/glsp-diagram-manager");
const glsp_layout_commands_1 = require("./diagram/glsp-layout-commands");
const glsp_client_contribution_1 = require("./glsp-client-contribution");
const theia_navigate_to_marker_contribution_1 = require("./theia-navigate-to-marker-contribution");
/**
 *  The `GLSPTheiaFrontendModule` provides the necessary required module configuration
 *  to implement a theia GLSP diagram language integration.
 */
class GLSPTheiaFrontendModule extends inversify_1.ContainerModule {
    constructor() {
        super((bind, unbind, isBound, rebind) => this.initialize({ bind, unbind, isBound, rebind }));
        this.enableLayoutCommands = true;
        this.enableMarkerNavigationCommands = true;
        this.enableCopyPaste = false;
    }
    initialize(context) {
        this.bindGLSPClientContribution(context);
        this.bindDiagramConfiguration(context);
        this.bindDiagramWidgetFactory(context);
        this.configureDiagramManager(context);
        // Optional default configuration
        this.configureDiagramLayoutCommands(context);
        this.configureCopyPasteContextMenu(context);
        this.configureMarkerNavigationCommands(context);
        this.configure(context);
    }
    /**
     * Defines the binding for the glsp client contribution of the diagram integration. A {@link ConfigurableGLSPClientContribution}
     * with the same id as the diagramLanguage is bound. Can be overwritten in subclasses to provide a custom binding using
     * the {@link GLSPClientContribution} service identifier.
     *
     * For example:
     * ```typescript
     * context.bind(GLSPClientContribution).toSelf(MyCustomGLSPClientContribution);
     * ```
     * Note that glsp client contribution bindings are consumed via multi-injection. This means binding the {@link GLSPClientContribution}
     * service identifier in singleton scope has no effect.
     *
     * @param context the container context
     */
    bindGLSPClientContribution(context) {
        context.bind(glsp_client_contribution_1.GLSPClientContribution).toDynamicValue(ctx => {
            const childContainer = ctx.container.createChild();
            childContainer.bind(GLSPDiagramLanguage).toConstantValue(this.diagramLanguage);
            return childContainer.resolve(ConfigurableGLSPClientContribution);
        });
    }
    /**
     * Defines the binding for the {@link DiagramWidgetFactory} of the diagram integration. Per default a
     * factory that constructs a {@link GLSPDiagramWidget} instance is bound.
     * Can be overwritten in subclasses to provide a custom binding using
     * the {@link DiagramWidgetFactory} service identifier.
     *
     * For example:
     * ```typescript
     * context.bind(DiagramWidgetFactory)
     *  .toDynamicValue(ctx => createDiagramWidgetFactory(ctx, this.diagramLanguage.diagramType, MyDiagramWidget));
     *
     * ```
     * Note that glsp diagram factory bindings are consumed via multi-injection. This means binding the {@link DiagramWidgetFactory}
     * service identifier in singleton scope has no effect.
     *
     * @param context the container context
     */
    bindDiagramWidgetFactory(context) {
        var _a;
        (_a = (0, client_1.lazyBind)(context, _1.GLSPDiagramWidget)) === null || _a === void 0 ? void 0 : _a.toSelf();
        context.bind(diagram_widget_factory_1.DiagramWidgetFactory).toDynamicValue(ctx => (0, diagram_widget_factory_1.createDiagramWidgetFactory)(ctx, this.diagramLanguage.diagramType));
    }
    /**
     * Configures the bindings for the diagram manager of the diagram integration. A {@link ConfigurableGLSPDiagramManager}
     * is bound to a generated service identifier in singleton scope and then additional bindings for this service
     * identifier are registered. Can be overwritten in subclasses to provide a custom binding.
     *
     *  For example:
     * ```typescript
     * context.bind(MyDiagramManager).to(MyDiagramManager).inSingletonScope();
     * registerDiagramManager(context.bind, MyDiagramManager);
     * ```
     * @param context the container context
     */
    configureDiagramManager(context) {
        const diagramManagerServiceId = Symbol(`DiagramManager_${this.diagramLanguage.diagramType}`);
        context
            .bind(diagramManagerServiceId)
            .toDynamicValue(ctx => {
            const childContainer = ctx.container.createChild();
            childContainer.bind(GLSPDiagramLanguage).toConstantValue(this.diagramLanguage);
            return childContainer.resolve(InternalGLSPDiagramManager);
        })
            .inSingletonScope();
        (0, glsp_diagram_manager_1.registerDiagramManager)(context.bind, diagramManagerServiceId, false);
    }
    /**
     * Can be overwritten by subclasses to provide additional configuration (e.g. extra bindings)
     * for this module.
     *
     * For example:
     * ```typescript
     * context.bind(MyCustomClass).toSelf().inSingletonScope()
     * ```
     * @param context the container context
     */
    configure(context) {
        // Empty per default
    }
    /**
     * Optional configuration to enable the default diagram layout commands for the diagram integration.
     * Can be enabled/disabled using the {@link GLSPTheiaFrontendModule.enableLayoutCommands}  property flag.
     *
     * @param context the diagram context
     */
    configureDiagramLayoutCommands(context) {
        if (this.enableLayoutCommands) {
            (0, glsp_layout_commands_1.registerDiagramLayoutCommands)(context);
        }
    }
    /**
     * Optional configuration for copy & paste functionality of the diagram integration.
     * Can be enabled/disabled using the {@link GLSPTheiaFrontendModule.enableCopyPaste} property flag.
     * Note that the glsp server also needs to support copy & paste for this diagram configuration.
     *
     * @param context the diagram context
     */
    configureCopyPasteContextMenu(context) {
        if (this.enableCopyPaste) {
            (0, copy_paste_context_menu_contribution_1.registerCopyPasteContextMenu)(context);
        }
    }
    /**
     * Optional configuration to enable marker navigation for the diagram integration.
     * Can be enabled/disabled using the {@link GLSPTheiaFrontendModule.enableMarkerNavigationCommands}  property flag.
     * Note that the glsp server also needs to support copy & paste for this diagram configuration.
     *
     * @param context the diagram context
     */
    configureMarkerNavigationCommands(context) {
        if (this.enableMarkerNavigationCommands) {
            (0, theia_navigate_to_marker_contribution_1.registerMarkerNavigationCommands)(context);
        }
    }
}
exports.GLSPTheiaFrontendModule = GLSPTheiaFrontendModule;
const GLSPDiagramLanguage = Symbol('GLSPDiagramLanguage');
/**
 * Internal class that is used in {@link GLSPTheiaFrontendModule.configureDiagramManager} to
 * bind a default implementation for `DiagramManager`. A custom `DiagramManager` should
 * never extend this class. Use {@link GLSPDiagramManager} instead.
 */
let InternalGLSPDiagramManager = class InternalGLSPDiagramManager extends glsp_diagram_manager_1.GLSPDiagramManager {
    constructor(diagramLanguage) {
        super();
        this._fileExtensions = [];
        this._iconClass = (0, client_1.codiconCSSString)('type-hierarchy-sub');
        this._fileExtensions = diagramLanguage.fileExtensions;
        this._diagramType = diagramLanguage.diagramType;
        this._label = diagramLanguage.label;
        this._iconClass = diagramLanguage.iconClass || this._iconClass;
        this._contributionId = diagramLanguage.contributionId;
        this._providerName = diagramLanguage.providerName;
    }
    get fileExtensions() {
        return this._fileExtensions;
    }
    get diagramType() {
        return this._diagramType;
    }
    get label() {
        return this._label;
    }
    get contributionId() {
        return this._contributionId;
    }
    get providerName() {
        return this._providerName;
    }
    get iconClass() {
        return this._iconClass;
    }
};
InternalGLSPDiagramManager = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(GLSPDiagramLanguage)),
    __metadata("design:paramtypes", [Object])
], InternalGLSPDiagramManager);
/**
 * Internal class that is used in {@link GLSPTheiaFrontendModule.bindGLSPClientContribution} to
 * bind a default implementation for {@link GLSPClientContribution}. A custom {@link GLSPClientContribution}  should
 * never extend this class. Use {@link BaseGLSPClientContribution} instead.
 */
let ConfigurableGLSPClientContribution = class ConfigurableGLSPClientContribution extends glsp_client_contribution_1.BaseGLSPClientContribution {
    constructor(diagramLanguage) {
        super();
        this.id = diagramLanguage.contributionId;
    }
};
ConfigurableGLSPClientContribution = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(GLSPDiagramLanguage)),
    __metadata("design:paramtypes", [Object])
], ConfigurableGLSPClientContribution);
//# sourceMappingURL=glsp-theia-container-module.js.map