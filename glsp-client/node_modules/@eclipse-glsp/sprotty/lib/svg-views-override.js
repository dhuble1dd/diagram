"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircularNodeView = exports.DiamondNodeView = void 0;
exports.hiddenBoundingRect = hiddenBoundingRect;
exports.applyHiddenBoundingRect = applyHiddenBoundingRect;
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/** @jsx svg */
const protocol_1 = require("@eclipse-glsp/protocol");
const inversify_1 = require("inversify");
const sprotty_1 = require("sprotty");
let DiamondNodeView = class DiamondNodeView extends sprotty_1.DiamondNodeView {
    render(node, context, args) {
        // The super class may change the bounds of the given node as browsers may calculate larger bounds for the rendered node (BBox).
        // To ensure that the node's bounds remains unchanged, we render a rectangle with the correct bounds during hidden rendering.
        return applyHiddenBoundingRect(node, context, super.render(node, context, args));
    }
};
exports.DiamondNodeView = DiamondNodeView;
exports.DiamondNodeView = DiamondNodeView = __decorate([
    (0, inversify_1.injectable)()
], DiamondNodeView);
let CircularNodeView = class CircularNodeView extends sprotty_1.CircularNodeView {
    render(node, context, args) {
        // The super class may change the bounds of the given node as browsers may calculate larger bounds for the rendered node (BBox).
        // To ensure that the node's bounds remains unchanged, we render a rectangle with the correct bounds during hidden rendering.
        return applyHiddenBoundingRect(node, context, super.render(node, context, args));
    }
};
exports.CircularNodeView = CircularNodeView;
exports.CircularNodeView = CircularNodeView = __decorate([
    (0, inversify_1.injectable)()
], CircularNodeView);
function hiddenBoundingRect(withBounds, context) {
    // an element with attribute ATTR_BBOX_ELEMENT is used by the hidden bounds updater to determine the bounds if it is within a g-element
    // we set the fill to transparent since the SVG export uses the hidden rendering to generate the image and we do not want to be seen
    return !context || context.targetKind === 'hidden' ? ((0, sprotty_1.svg)("rect", { attrs: { [sprotty_1.ATTR_BBOX_ELEMENT]: true }, ...protocol_1.Bounds.dimension(withBounds.bounds), style: { fill: 'transparent' } })) : undefined;
}
/**
 * Applies a hidden bounding rectangle to the given view if we are in the hidden rendering context where sizes are being determined.
 *
 * @param withBounds The element to apply the hidden bounding rectangle to.
 * @param context The rendering context.
 * @param view The view to apply the hidden bounding rectangle to.
 * @returns The view with the hidden bounding rectangle applied, wrapped in a group element if necessary.
 */
function applyHiddenBoundingRect(withBounds, context, view) {
    var _a;
    if (view && context.targetKind === 'hidden') {
        const parent = view.sel === 'g' ? view : (0, sprotty_1.svg)("g", null, view);
        (_a = parent.children) === null || _a === void 0 ? void 0 : _a.unshift(hiddenBoundingRect(withBounds));
        return parent;
    }
    return view;
}
//# sourceMappingURL=svg-views-override.js.map