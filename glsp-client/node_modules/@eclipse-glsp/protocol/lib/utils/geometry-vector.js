"use strict";
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vector = void 0;
const geometry_util_1 = require("./geometry-util");
const type_util_1 = require("./type-util");
/**
 * A collection of utility functions for working with vectors.
 */
var Vector;
(function (Vector) {
    /**
     * The zero vector. It has x and y set to 0.
     */
    Vector.ZERO = Object.freeze({
        x: 0,
        y: 0
    });
    /**
     * Compute the absolute value of the vector.
     * @param vector the vector to compute the absolute value of
     * @returns the absolute value of the vector
     */
    function abs(vector) {
        return { x: Math.abs(vector.x), y: Math.abs(vector.y) };
    }
    Vector.abs = abs;
    /**
     * Computes the sum of two vectors.
     * @param vector the vector to add to
     * @param addend the vector to add
     * @returns the sum of the two vectors
     */
    function add(vector, addend) {
        return { x: vector.x + addend.x, y: vector.y + addend.y };
    }
    Vector.add = add;
    /**
     * Check if two vectors are equal.
     * @param left the left vector
     * @param right the right vector
     * @returns true if the vectors are equal, false otherwise
     */
    function equals(left, right) {
        return left.x === right.x && left.y === right.y;
    }
    Vector.equals = equals;
    /**
     * Check if a vector is valid. A vector is valid if it is not undefined and both x and y are numbers.
     * @param vector the vector to check
     * @returns true if the vector is valid, false otherwise
     */
    function isValid(vector) {
        return vector !== undefined && !isNaN(vector.x) && !isNaN(vector.y);
    }
    Vector.isValid = isValid;
    /**
     * Computes the magnitude of a vector defined as the square root of the sum of the squares of the x and y components.
     * @param point the vector to compute the magnitude of
     * @returns the magnitude of the vector
     */
    function magnitude(point) {
        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
    }
    Vector.magnitude = magnitude;
    /**
     * Maps each component of the vector to a new value given by the callback function.
     * @param vector the vector to map
     * @param callbackfn the function to map the components
     * @returns the mapped vector
     */
    function map(vector, callbackfn) {
        return {
            ...vector,
            x: callbackfn(vector.x, 'x'),
            y: callbackfn(vector.y, 'y')
        };
    }
    Vector.map = map;
    /**
     * Computes the normalized vector of a given vector.
     * The normalized vector has the same direction as the original vector but a magnitude of 1.
     *
     * @param vector the vector to normalize
     * @returns the normalized vector
     */
    function normalize(vector) {
        const mag = magnitude(vector);
        if (mag === 0 || mag === 1) {
            return Vector.ZERO;
        }
        return {
            x: vector.x / mag,
            y: vector.y / mag
        };
    }
    Vector.normalize = normalize;
    /**
     * Check if a vector is the zero vector.
     * @param vector the vector to check
     * @returns true if the vector is the zero vector, false otherwise
     */
    function isZero(vector) {
        return Vector.equals(vector, Vector.ZERO);
    }
    Vector.isZero = isZero;
    /**
     * Type guard to check if a value is a vector.
     * @param vector the value to check
     * @returns true if the value is a vector, false otherwise
     */
    function is(vector) {
        return type_util_1.AnyObject.is(vector) && (0, type_util_1.hasNumberProp)(vector, 'x') && (0, type_util_1.hasNumberProp)(vector, 'y');
    }
    Vector.is = is;
    /**
     * Divides each component of the vector by a scalar.
     *
     * @param vector the vector to divide
     * @param scalar the scalar to divide by
     * @returns the divided vector
     */
    function divide(vector, scalar) {
        return Vector.map(vector, coordinate => coordinate / scalar);
    }
    Vector.divide = divide;
    /**
     * Multiplies each component of the vector by a scalar.
     *
     * @param vector the vector to multiply
     * @param scalar the scalar to multiply by
     * @returns the multiplied vector
     */
    function multiply(vector, scalar) {
        return Vector.map(vector, coordinate => coordinate * scalar);
    }
    Vector.multiply = multiply;
    /**
     * Subtracts the subtrahend from the vector.
     *
     * @param vector the vector to subtract from
     * @param subtrahend the vector to subtract
     * @returns the subtracted vector
     */
    function subtract(vector, subtrahend) {
        return { x: vector.x - subtrahend.x, y: vector.y - subtrahend.y };
    }
    Vector.subtract = subtract;
    /**
     * Reverse the direction of a vector.
     * @param vector the vector to reverse
     * @returns the reversed vector
     */
    function reverse(vector) {
        return { x: -vector.x, y: -vector.y };
    }
    Vector.reverse = reverse;
    /**
     * Computes the direction of a vector
     * @param vector the vector to compute the direction of
     * @returns the direction of the vector
     */
    function direction(vector) {
        const directions = [];
        if (vector.x < 0) {
            directions.push(geometry_util_1.Direction.Left);
        }
        else if (vector.x > 0) {
            directions.push(geometry_util_1.Direction.Right);
        }
        if (vector.y < 0) {
            directions.push(geometry_util_1.Direction.Up);
        }
        else if (vector.y > 0) {
            directions.push(geometry_util_1.Direction.Down);
        }
        return directions;
    }
    Vector.direction = direction;
    /**
     * Computes a vector that is the minimum of all given vectors.
     * @returns the minimum vector
     */
    function min(...vectors) {
        return {
            x: Math.min(...vectors.map(vector => vector.x)),
            y: Math.min(...vectors.map(vector => vector.y))
        };
    }
    Vector.min = min;
    /**
     * Computes a vector that is the maximum of all given vectors.
     * @returns the maximum vector
     */
    function max(...vectors) {
        return {
            x: Math.max(...vectors.map(vector => vector.x)),
            y: Math.max(...vectors.map(vector => vector.y))
        };
    }
    Vector.max = max;
    /**
     * Computes a vector that is the average of all given vectors.
     * @returns the average vector
     */
    function avg(...vectors) {
        if (vectors.length === 0) {
            return Vector.ZERO;
        }
        return {
            x: vectors.reduce((prev, cur) => prev + cur.x, 0) / vectors.length,
            y: vectors.reduce((prev, cur) => prev + cur.y, 0) / vectors.length
        };
    }
    Vector.avg = avg;
})(Vector || (exports.Vector = Vector = {}));
//# sourceMappingURL=geometry-vector.js.map