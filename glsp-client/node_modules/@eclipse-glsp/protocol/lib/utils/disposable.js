"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisposableCollection = exports.Disposable = void 0;
const array_util_1 = require("../utils/array-util");
const type_util_1 = require("../utils/type-util");
var Disposable;
(function (Disposable) {
    function is(value) {
        return type_util_1.AnyObject.is(value) && (0, type_util_1.hasFunctionProp)(value, 'dispose');
    }
    Disposable.is = is;
    /**
     * Creates a new empty i.e. no-op {@link Disposable}.
     * @returns the newly created disposable
     */
    function empty() {
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        return { dispose: () => { } };
    }
    Disposable.empty = empty;
    /**
     * Creates a new {@link Disposable} that delegates to the given callback.
     * @param cb The callback that should be invoked on dispose
     * @returns the newly created disposable
     */
    function create(cb) {
        return { dispose: cb };
    }
    Disposable.create = create;
    /**
     * Disposes the given object if it is a {@link Disposable}.
     * @param value The object that should be disposed
     */
    function dispose(value) {
        if (is(value)) {
            value.dispose();
        }
    }
    Disposable.dispose = dispose;
})(Disposable || (exports.Disposable = Disposable = {}));
/**
 * Reusable base class to manage a collection of {@link Disposable}s.
 */
class DisposableCollection {
    constructor(...toDispose) {
        this.disposables = [];
        toDispose.forEach(d => this.push(d));
        this.errorHandler = err => console.error(err);
    }
    dispose() {
        var _a, _b;
        if (this.disposed) {
            return;
        }
        try {
            while (!this.disposed) {
                (_a = this.disposables.pop()) === null || _a === void 0 ? void 0 : _a.dispose();
            }
        }
        catch (err) {
            (_b = this.errorHandler) === null || _b === void 0 ? void 0 : _b.call(this, err);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    push(...disposables) {
        const toAdd = (0, array_util_1.isArrayOfType)(disposables, Disposable.is) ? disposables : disposables.map(Disposable.create);
        this.disposables.push(...toAdd);
        return Disposable.create(() => (0, array_util_1.remove)(this.disposables, ...toAdd));
    }
    get isDisposed() {
        return this.disposed;
    }
    /**
     * Removes all disposables in this collection WITHOUT triggering their disposal behavior.
     */
    clear() {
        this.disposables.length = 0;
    }
}
exports.DisposableCollection = DisposableCollection;
//# sourceMappingURL=disposable.js.map