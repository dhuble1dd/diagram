"use strict";
/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLSPWebSocketProvider = exports.GLSPConnectionHandler = void 0;
const websocket_connection_1 = require("./websocket-connection");
exports.GLSPConnectionHandler = Symbol('GLSPConnectionHandler');
class GLSPWebSocketProvider {
    constructor(url, options) {
        this.url = url;
        this.reconnectAttempts = 0;
        this.options = {
            // default values
            reconnecting: true,
            reconnectAttempts: Infinity,
            reconnectDelay: 1000
        };
        this.options = Object.assign(this.options, options);
    }
    createWebSocket(url) {
        return new WebSocket(url);
    }
    listen(handler, isReconnecting = false) {
        this.webSocket = this.createWebSocket(this.url);
        this.webSocket.onerror = () => {
            var _a;
            (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.error('GLSPWebSocketProvider Connection to server errored. Please make sure that the server is running!');
            clearInterval(this.reconnectTimer);
            this.webSocket.close();
        };
        return new Promise(resolve => {
            this.webSocket.onopen = () => {
                var _a, _b, _c, _d;
                clearInterval(this.reconnectTimer);
                const wrappedSocket = (0, websocket_connection_1.wrap)(this.webSocket);
                const wsConnection = (0, websocket_connection_1.createWebSocketConnection)(wrappedSocket, handler.logger);
                this.webSocket.onclose = () => {
                    var _a, _b;
                    const { reconnecting, reconnectAttempts, reconnectDelay } = this.options;
                    if (reconnecting) {
                        if (this.reconnectAttempts >= reconnectAttempts) {
                            (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.error('GLSPWebSocketProvider WebSocket reconnect failed - maximum number reconnect attempts ' +
                                `(${reconnectAttempts}) was exceeded!`);
                        }
                        else {
                            this.reconnectTimer = setInterval(() => {
                                var _a;
                                (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn('GLSPWebSocketProvider reconnecting...');
                                this.listen(handler, true);
                                this.reconnectAttempts++;
                            }, reconnectDelay);
                        }
                    }
                    else {
                        (_b = handler.logger) === null || _b === void 0 ? void 0 : _b.error('GLSPWebSocketProvider WebSocket will not reconnect - closing the connection now!');
                    }
                };
                if (isReconnecting) {
                    (_a = handler.logger) === null || _a === void 0 ? void 0 : _a.warn('GLSPWebSocketProvider Reconnecting!');
                    (_b = handler.onReconnect) === null || _b === void 0 ? void 0 : _b.call(handler, wsConnection);
                }
                else {
                    (_c = handler.logger) === null || _c === void 0 ? void 0 : _c.warn('GLSPWebSocketProvider Initializing!');
                    (_d = handler.onConnection) === null || _d === void 0 ? void 0 : _d.call(handler, wsConnection);
                }
                resolve(wsConnection);
            };
        });
    }
}
exports.GLSPWebSocketProvider = GLSPWebSocketProvider;
//# sourceMappingURL=ws-connection-provider.js.map