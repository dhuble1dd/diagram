"use strict";
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounds = void 0;
const geometry_1 = require("sprotty-protocol/lib/utils/geometry");
Object.defineProperty(exports, "Bounds", { enumerable: true, get: function () { return geometry_1.Bounds; } });
const sprotty_geometry_dimension_1 = require("./sprotty-geometry-dimension");
const sprotty_geometry_point_1 = require("./sprotty-geometry-point");
const type_util_1 = require("./utils/type-util");
geometry_1.Bounds.ZERO = Object.freeze({
    x: 0,
    y: 0,
    width: 0,
    height: 0
});
geometry_1.Bounds.is = (bounds) => type_util_1.AnyObject.is(bounds) &&
    (0, type_util_1.hasNumberProp)(bounds, 'x') &&
    (0, type_util_1.hasNumberProp)(bounds, 'y') &&
    (0, type_util_1.hasNumberProp)(bounds, 'width') &&
    (0, type_util_1.hasNumberProp)(bounds, 'height');
geometry_1.Bounds.isValid = (bounds) => bounds !== undefined && sprotty_geometry_dimension_1.Dimension.isValid(bounds) && sprotty_geometry_point_1.Point.isValid(bounds);
geometry_1.Bounds.encompasses = (outer, inner) => geometry_1.Bounds.includes(outer, geometry_1.Bounds.topLeft(inner)) && geometry_1.Bounds.includes(outer, geometry_1.Bounds.bottomRight(inner));
geometry_1.Bounds.overlap = (one, other, touch) => {
    const oneTopLeft = geometry_1.Bounds.topLeft(one);
    const oneBottomRight = geometry_1.Bounds.bottomRight(one);
    const otherTopLeft = geometry_1.Bounds.topLeft(other);
    const otherBottomRight = geometry_1.Bounds.bottomRight(other);
    return touch
        ? oneTopLeft.x <= otherBottomRight.x &&
            otherTopLeft.x <= oneBottomRight.x &&
            oneBottomRight.y >= otherTopLeft.y &&
            otherBottomRight.y >= oneTopLeft.y
        : oneTopLeft.x < otherBottomRight.x &&
            otherTopLeft.x < oneBottomRight.x &&
            oneBottomRight.y > otherTopLeft.y &&
            otherBottomRight.y > oneTopLeft.y;
};
geometry_1.Bounds.equals = (left, right, eps) => sprotty_geometry_point_1.Point.equals(left, right, eps) && sprotty_geometry_dimension_1.Dimension.equals(left, right, eps);
geometry_1.Bounds.left = (bounds) => bounds.x;
geometry_1.Bounds.centerX = (bounds) => bounds.x + (bounds.width >= 0 ? bounds.width * 0.5 : 0);
geometry_1.Bounds.right = (bounds) => bounds.x + bounds.width;
geometry_1.Bounds.top = (bounds) => bounds.y;
geometry_1.Bounds.middle = (bounds) => bounds.y + (bounds.height >= 0 ? bounds.height * 0.5 : 0);
geometry_1.Bounds.centerY = geometry_1.Bounds.middle;
geometry_1.Bounds.bottom = (bounds) => bounds.y + bounds.height;
geometry_1.Bounds.topLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.topCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.topRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.top(bounds) });
geometry_1.Bounds.middleLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.middleCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.middleRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.middle(bounds) });
geometry_1.Bounds.bottomLeft = (bounds) => ({ x: geometry_1.Bounds.left(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.bottomCenter = (bounds) => ({ x: geometry_1.Bounds.centerX(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.bottomRight = (bounds) => ({ x: geometry_1.Bounds.right(bounds), y: geometry_1.Bounds.bottom(bounds) });
geometry_1.Bounds.isAbove = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) <= geometry_1.Bounds.top(rightBounds);
geometry_1.Bounds.isBelow = (leftBounds, rightBounds) => geometry_1.Bounds.top(leftBounds) >= geometry_1.Bounds.top(rightBounds);
geometry_1.Bounds.isBefore = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) < geometry_1.Bounds.left(rightBounds);
geometry_1.Bounds.isAfter = (leftBounds, rightBounds) => geometry_1.Bounds.left(leftBounds) >= geometry_1.Bounds.left(rightBounds);
geometry_1.Bounds.sortBy = (rankFunc, ...bounds) => bounds.sort((left, right) => rankFunc(left) - rankFunc(right));
geometry_1.Bounds.from = (topLeft, bottomRight) => ({
    ...topLeft,
    width: bottomRight.x - topLeft.x,
    height: bottomRight.y - topLeft.y
});
geometry_1.Bounds.position = geometry_1.Bounds.topLeft;
geometry_1.Bounds.dimension = (bounds) => ({ width: bounds.width, height: bounds.height });
geometry_1.Bounds.move = geometry_1.Bounds.translate;
geometry_1.Bounds.resize = (bounds, delta) => ({
    ...bounds,
    width: bounds.width + delta.width,
    height: bounds.height + delta.height
});
//# sourceMappingURL=sprotty-geometry-bounds.js.map