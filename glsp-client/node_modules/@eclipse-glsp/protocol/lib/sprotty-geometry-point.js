"use strict";
/********************************************************************************
 * Copyright (c) 2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Point = void 0;
const geometry_1 = require("sprotty-protocol/lib/utils/geometry");
Object.defineProperty(exports, "Point", { enumerable: true, get: function () { return geometry_1.Point; } });
const geometry_vector_1 = require("./utils/geometry-vector");
const math_util_1 = require("./utils/math-util");
const type_util_1 = require("./utils/type-util");
geometry_1.Point.is = (point) => type_util_1.AnyObject.is(point) && (0, type_util_1.hasNumberProp)(point, 'x') && (0, type_util_1.hasNumberProp)(point, 'y');
geometry_1.Point.isOrigin = (point) => geometry_1.Point.equals(point, geometry_1.Point.ORIGIN);
geometry_1.Point.isValid = (point) => point !== undefined && !isNaN(point.x) && !isNaN(point.y);
geometry_1.Point.abs = (point) => geometry_1.Point.map(point, Math.abs);
geometry_1.Point.divideScalar = (point, scalar) => geometry_1.Point.map(point, coordinate => coordinate / scalar);
geometry_1.Point.multiplyScalar = (point, scalar) => geometry_1.Point.map(point, coordinate => coordinate * scalar);
geometry_1.Point.map = (point, callbackfn) => ({
    ...point,
    x: callbackfn(point.x, 'x'),
    y: callbackfn(point.y, 'y')
});
geometry_1.Point.snapToGrid = (point, grid, gridOrigin) => {
    if (gridOrigin) {
        // move point relative to grid origin and then restore after snapping
        const relative = geometry_1.Point.subtract(point, gridOrigin);
        const snapped = geometry_1.Point.snapToGrid(relative, grid);
        return geometry_1.Point.add(gridOrigin, snapped);
    }
    else {
        return { x: Math.round(point.x / grid.x) * grid.x, y: Math.round(point.y / grid.y) * grid.y };
    }
};
geometry_1.Point.vector = (from, to) => geometry_1.Point.subtract(to, from);
geometry_1.Point.move = (from, to) => {
    const vector = geometry_1.Point.vector(from, to);
    const direction = geometry_vector_1.Vector.direction(vector);
    return { from, to, vector, direction };
};
geometry_1.Point.moveTowards = (from, vector) => {
    const to = geometry_1.Point.add(from, vector);
    const dir = geometry_vector_1.Vector.direction(vector);
    return { from, to, vector, direction: dir };
};
geometry_1.Point.equals = (one, other, eps) => (0, math_util_1.equalUpTo)(one.x, other.x, eps) && (0, math_util_1.equalUpTo)(one.y, other.y, eps);
//# sourceMappingURL=sprotty-geometry-point.js.map