"use strict";
/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeContainer = initializeContainer;
exports.resolveContainerConfiguration = resolveContainerConfiguration;
const array_util_1 = require("../utils/array-util");
const type_util_1 = require("../utils/type-util");
const feature_module_1 = require("./feature-module");
/**
 * Initializes a container with the given {@link ContainerConfiguration}. The container configuration
 * consists of the set of {@link ContainerModule}s that should be loaded in the container.
 * In addition, for more fine-grained control {@link ModuleConfiguration}s can be passed as part fo the container configuration
 * Module loading is distinct,this means each module will only get loaded once even if it is configured multiple times.
  @param containerConfigurations
 *          Custom modules to be loaded in addition to the default modules and/or default modules that should be excluded.
  @returns The initialized container.
 */
function initializeContainer(container, ...containerConfigurations) {
    const modules = resolveContainerConfiguration(...containerConfigurations);
    container.load(...modules);
    return container;
}
/**
 * Processes the given container configurations and returns the corresponding set of {@link ContainerModule}s.
 * Container configurations are processed in the order they are passed. If a module is configured to be removed
 * it can be added again in a later configuration. This also means in case of `replace` configurations that affect the same feature id
 * the last configuration wins.
 * @param containerConfigurations The container configurations to resolve
 * @throws An error if featureModule ids are not unique in the resolved module array
 * @returns an Array of resolved container modules
 */
function resolveContainerConfiguration(...containerConfigurations) {
    const modules = [];
    containerConfigurations.forEach(config => {
        if (isContainerModule(config)) {
            (0, array_util_1.distinctAdd)(modules, config);
        }
        else {
            if (config.remove) {
                (0, array_util_1.remove)(modules, ...(0, array_util_1.asArray)(config.remove));
            }
            if (config.add) {
                (0, array_util_1.distinctAdd)(modules, ...(0, array_util_1.asArray)(config.add));
            }
            if (config.replace) {
                (0, array_util_1.asArray)(config.replace).forEach(replace => {
                    const existingIndex = modules.findIndex(m => m instanceof feature_module_1.FeatureModule && m.featureId === replace.featureId);
                    if (existingIndex >= 0) {
                        modules[existingIndex] = replace;
                    }
                    else {
                        console.warn(`Could not find module to replace with feature id ${replace.featureId.toString()}.` +
                            'Adding replacement module to the end of the resolved configurations.');
                        (0, array_util_1.distinctAdd)(modules, replace);
                    }
                });
            }
        }
    });
    // Check for duplicate feature ids in resolved modules
    const featureIds = new Set();
    const duplicates = [];
    modules.forEach(module => {
        if (module instanceof feature_module_1.FeatureModule) {
            if (featureIds.has(module.featureId)) {
                duplicates.push(module);
            }
            else {
                featureIds.add(module.featureId);
            }
        }
    });
    if (duplicates.length > 0) {
        const culprits = duplicates.map(m => m.featureId.toString()).join(', ');
        throw new Error(`Could not resolve container configuration. Non-unique feature ids found in container configuration: ${culprits}`);
    }
    return modules;
}
/**
 * The container modules might originate form different inversify contexts (e.g. `inversify` vs. `@theia/core/shared/inversify`).
 * If this is the case an instanceof check can return  false negative.
 * => use a simple typeguard instead.
 */
function isContainerModule(config) {
    return (0, type_util_1.hasNumberProp)(config, 'id') && (0, type_util_1.hasFunctionProp)(config, 'registry');
}
//# sourceMappingURL=container-configuration.js.map