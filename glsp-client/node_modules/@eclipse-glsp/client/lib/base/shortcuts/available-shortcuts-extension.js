"use strict";
/********************************************************************************
 * Copyright (c) 2023-2025 Business Informatics Group (TU Wien) and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var AvailableShortcutsUIExtension_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvailableShortcutsUIExtension = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const lodash_1 = require("lodash");
const ui_extension_1 = require("../../base/ui-extension/ui-extension");
const messages_1 = require("../messages");
let AvailableShortcutsUIExtension = AvailableShortcutsUIExtension_1 = class AvailableShortcutsUIExtension extends ui_extension_1.GLSPAbstractUIExtension {
    id() {
        return AvailableShortcutsUIExtension_1.ID;
    }
    containerClass() {
        return AvailableShortcutsUIExtension_1.ID;
    }
    show(root, ...contextElementIds) {
        super.show(root, ...contextElementIds);
        this.shortcutsContainer.focus();
        this.toDisposeOnHide.push(this.shortcutManager.onDidChange(() => this.refreshUI()));
    }
    refreshUI() {
        this.shortcutsContainer.innerHTML = '';
        const registrations = this.shortcutManager.getRegistrations();
        registrations.sort((a, b) => {
            if (a.group < b.group) {
                return -1;
            }
            if (a.group > b.group) {
                return 1;
            }
            return a.position - b.position;
        });
        const grouped = (0, lodash_1.groupBy)(registrations, k => k.group);
        const groupTable = document.createElement('table');
        groupTable.classList.add('shortcut-table');
        const tableHead = document.createElement('thead');
        const tableBody = document.createElement('tbody');
        const headerRow = document.createElement('tr');
        const commandCell = document.createElement('th');
        const keybindingCell = document.createElement('th');
        commandCell.classList.add('column-title');
        commandCell.innerText = messages_1.messages.shortcut.header_command;
        keybindingCell.innerText = messages_1.messages.shortcut.header_shortcut;
        headerRow.appendChild(commandCell);
        headerRow.appendChild(keybindingCell);
        tableHead.appendChild(headerRow);
        for (const [group, shortcuts] of Object.entries(grouped)) {
            tableBody.appendChild(this.createGroupHeader(group));
            shortcuts.forEach(s => {
                tableBody.appendChild(this.createEntry(s));
            });
        }
        groupTable.appendChild(tableHead);
        groupTable.appendChild(tableBody);
        this.shortcutsContainer.append(groupTable);
    }
    createGroupHeader(group) {
        const entryRow = document.createElement('tr');
        const groupElement = document.createElement('td');
        const text = document.createElement('strong');
        const emptyElement = document.createElement('td');
        text.innerText = group;
        groupElement.appendChild(text);
        entryRow.appendChild(groupElement);
        entryRow.appendChild(emptyElement);
        return entryRow;
    }
    getShortcutHTML(shortcuts) {
        const shortcutKeys = document.createElement('span');
        shortcutKeys.innerHTML = shortcuts.map(key => `<kbd>${key}</kbd>`).join(' + ');
        return shortcutKeys;
    }
    createEntry(registration) {
        const entryRow = document.createElement('tr');
        const shortcutElement = document.createElement('td');
        const descElement = document.createElement('td');
        const shortcut = this.getShortcutHTML(registration.shortcuts);
        descElement.innerText = registration.description;
        shortcutElement.appendChild(shortcut);
        entryRow.appendChild(descElement);
        entryRow.appendChild(shortcutElement);
        return entryRow;
    }
    initializeContents(containerElement) {
        this.container = document.createElement('div');
        this.container.classList.add('keyboard-shortcuts-menu');
        // create title
        const menuTitle = document.createElement('h3');
        menuTitle.classList.add('menu-header');
        menuTitle.innerText = messages_1.messages.shortcut.title;
        this.container.appendChild(menuTitle);
        const closeBtn = document.createElement('button');
        closeBtn.id = 'key-shortcut-close-btn';
        closeBtn.textContent = 'x';
        closeBtn.addEventListener('click', () => {
            this.hide();
        });
        this.container.appendChild(closeBtn);
        // create shortcuts container
        this.shortcutsContainer = document.createElement('div');
        this.shortcutsContainer.classList.add('keyboard-shortcuts-container');
        this.shortcutsContainer.tabIndex = 30;
        this.shortcutsContainer.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' || (0, sprotty_1.matchesKeystroke)(event, 'KeyH', 'alt')) {
                this.hide();
            }
        });
        this.container.appendChild(this.shortcutsContainer);
        containerElement.appendChild(this.container);
        containerElement.ariaLabel = messages_1.messages.shortcut.menu_title;
        this.refreshUI();
    }
};
exports.AvailableShortcutsUIExtension = AvailableShortcutsUIExtension;
AvailableShortcutsUIExtension.ID = 'key-shortcut';
__decorate([
    (0, inversify_1.inject)(sprotty_1.TYPES.IShortcutManager),
    __metadata("design:type", Object)
], AvailableShortcutsUIExtension.prototype, "shortcutManager", void 0);
exports.AvailableShortcutsUIExtension = AvailableShortcutsUIExtension = AvailableShortcutsUIExtension_1 = __decorate([
    (0, inversify_1.injectable)()
], AvailableShortcutsUIExtension);
//# sourceMappingURL=available-shortcuts-extension.js.map