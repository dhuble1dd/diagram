/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, Command, CommandExecutionContext, Disposable, DisposableCollection, Emitter, Event, GModelElement, GModelRoot, ILogger, LazyInjector, SelectAction, SelectAllAction } from '@eclipse-glsp/sprotty';
import { SelectableElement } from '../utils/gmodel-util';
import { IGModelRootListener } from './editor-context-service';
import { IFeedbackActionDispatcher } from './feedback/feedback-action-dispatcher';
import { IDiagramStartup } from './model/diagram-loader';
export interface ISelectionListener {
    selectionChanged(root: Readonly<GModelRoot>, selectedElements: string[], deselectedElements?: string[]): void;
}
export declare namespace ISelectionListener {
    function is(object: unknown): object is ISelectionListener;
}
export interface SelectionChange {
    root: Readonly<GModelRoot>;
    selectedElements: string[];
    deselectedElements: string[];
}
export declare class SelectionService implements IGModelRootListener, Disposable, IDiagramStartup {
    protected feedbackDispatcher: IFeedbackActionDispatcher;
    protected lazyInjector: LazyInjector;
    protected logger: ILogger;
    protected root: Readonly<GModelRoot>;
    protected selectedElementIDs: Set<string>;
    protected toDispose: DisposableCollection;
    protected initialize(): void;
    preLoadDiagram(): void;
    dispose(): void;
    protected onSelectionChangedEmitter: Emitter<SelectionChange>;
    get onSelectionChanged(): Event<SelectionChange>;
    addListener(listener: ISelectionListener): Disposable;
    modelRootChanged(root: Readonly<GModelRoot>): void;
    updateSelection(newRoot: Readonly<GModelRoot>, select: string[], deselect: string[]): void;
    dispatchFeedback(actions: Action[]): void;
    notifyListeners(root: GModelRoot, selectedElementIDs: Set<string>, deselectedElementIDs: Set<string>): void;
    getModelRoot(): Readonly<GModelRoot>;
    getSelectedElements(): Readonly<SelectableElement>[];
    /**
     * QUERY METHODS
     */
    getSelectedElementIDs(): string[];
    hasSelectedElements(): boolean;
    isSingleSelection(): boolean;
    isMultiSelection(): boolean;
}
/**
 * Handles a {@link SelectAction} and propagates the new selection to the {@link SelectionService}.
 * Other tools might be selection-sensitive which means {@link SelectAction}s must be processed as fast as possible.
 * Handling the action with a command ensures that the action is processed before the next render tick.
 */
export declare class SelectCommand extends Command {
    action: SelectAction;
    selectionService: SelectionService;
    static readonly KIND = "elementSelected";
    protected selected: GModelElement[];
    protected deselected: GModelElement[];
    constructor(action: SelectAction, selectionService: SelectionService);
    execute(context: CommandExecutionContext): GModelRoot;
    undo(context: CommandExecutionContext): GModelRoot;
    redo(context: CommandExecutionContext): GModelRoot;
}
/**
 * Handles a {@link SelectAllAction} and propagates the new selection to the {@link SelectionService}.
 * Other tools might be selection-sensitive which means {@link SelectionAllAction}s must be processed as fast as possible.
 * Handling the action with a command ensures that the action is processed before the next render tick.
 */
export declare class SelectAllCommand extends Command {
    action: SelectAllAction;
    selectionService: SelectionService;
    static readonly KIND = "allSelected";
    protected previousSelection: Map<string, boolean>;
    constructor(action: SelectAllAction, selectionService: SelectionService);
    execute(context: CommandExecutionContext): GModelRoot;
    undo(context: CommandExecutionContext): GModelRoot;
    redo(context: CommandExecutionContext): GModelRoot;
}
export interface SelectFeedbackAction extends Omit<SelectAction, 'kind'>, Action {
    kind: typeof SelectFeedbackAction.KIND;
}
export declare namespace SelectFeedbackAction {
    const KIND = "selectFeedback";
    function is(object: any): object is SelectFeedbackAction;
    function create(options?: {
        selectedElementsIDs?: string[];
        deselectedElementsIDs?: string[] | boolean;
    }): SelectFeedbackAction;
    function addSelection(selectedElementsIDs: string[]): SelectFeedbackAction;
    function removeSelection(deselectedElementsIDs: string[]): SelectFeedbackAction;
    function setSelection(selectedElementsIDs: string[]): SelectFeedbackAction;
}
//# sourceMappingURL=selection-service.d.ts.map