/********************************************************************************
 * Copyright (c) 2020-2025 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, Args, Bounds, Disposable, DisposableCollection, EditorContext, Emitter, Event, GModelElement, GModelRoot, IActionDispatcher, IActionHandler, LazyInjector, MaybePromise, MousePositionTracker, SetDirtyStateAction, SetEditModeAction, ValueChange, Viewport } from '@eclipse-glsp/sprotty';
import { FocusChange, FocusTracker } from './focus/focus-tracker';
import { IDiagramOptions, IDiagramStartup } from './model/diagram-loader';
import { IModelChangeService, ViewportChange } from './model/model-change-service';
import { SelectionChange, SelectionService } from './selection-service';
/**
 * A hook to listen for model root changes. Will be called after a server update
 * has been processed
 */
export interface IGModelRootListener {
    modelRootChanged(root: Readonly<GModelRoot>): void;
}
/**
 * @deprecated Use {@link IGModelRootListener} instead
 */
export type ISModelRootListener = IGModelRootListener;
/**
 * A hook to listen for edit mode changes. Will be after the {@link EditorContextService}
 * has handled the {@link SetEditModeAction}.
 */
export interface IEditModeListener {
    editModeChanged(newValue: string, oldValue: string): void;
}
export type DirtyStateChange = Pick<SetDirtyStateAction, 'isDirty' | 'reason'>;
/**
 * The `EditorContextService` is a central injectable component that gives read-only access to
 * certain aspects of the diagram, such as the currently selected elements, the model root,
 * the edit mode, the latest position of the mouse in the diagram.
 *
 * It has been introduced for two main reasons:
 * 1. to simplify accessing the model root and the current selection from components that are
 *    not commands,
 * 2. to conveniently create an EditorContext, which is a context object sent as part of several
 *    actions to the server to describe the current state of the editor (selection, last mouse
 *    position, etc.).
 */
export declare class EditorContextService implements IActionHandler, Disposable, IDiagramStartup {
    protected selectionService: SelectionService;
    protected modelChangeService: IModelChangeService;
    protected mousePositionTracker: MousePositionTracker;
    protected lazyInjector: LazyInjector;
    protected diagramOptions: IDiagramOptions;
    protected actionDispatcher: IActionDispatcher;
    protected focusTracker: FocusTracker;
    protected _editMode: string;
    protected onEditModeChangedEmitter: Emitter<ValueChange<string>>;
    /**
     * Event that is fired when the edit mode of the diagram changes i.e. after a {@link SetEditModeAction} has been handled.
     */
    get onEditModeChanged(): Event<ValueChange<string>>;
    protected _isDirty: boolean;
    protected onDirtyStateChangedEmitter: Emitter<DirtyStateChange>;
    /**
     * Event that is fired when the dirty state of the diagram changes i.e. after a {@link SetDirtyStateAction} has been handled.
     */
    get onDirtyStateChanged(): Event<DirtyStateChange>;
    /**
     * Event that is fired when the model root of the diagram changes i.e. after the `CommandStack` has processed a model update.
     */
    get onModelRootChanged(): Event<Readonly<GModelRoot>>;
    /**
     * Event that is fired when the focus state of the diagram changes i.e. after a {@link FocusStateChangedAction} has been handled
     * by the {@link FocusTracker}.
     */
    get onFocusChanged(): Event<FocusChange>;
    /**
     * Event that is fired when the selection of the diagram changes i.e. a selection change has been handled
     * by the {@link SelectionService}.
     */
    get onSelectionChanged(): Event<SelectionChange>;
    /**
     * Event that is fired when the viewport of the diagram changes i.e. after the `CommandStack` has processed a viewport update.
     * By default, this event is only fired if the viewport was changed via a `SetViewportCommand` or `BoundsAwareViewportCommand`
     */
    get onViewportChanged(): Event<ViewportChange>;
    protected toDispose: DisposableCollection;
    protected initialize(): void;
    dispose(): void;
    preLoadDiagram(): MaybePromise<void>;
    get(args?: Args): EditorContext;
    getWithSelection(selectedElementIds: string[], args?: Args): EditorContext;
    handle(action: Action): void;
    protected handleSetEditModeAction(action: SetEditModeAction): void;
    protected handleSetDirtyStateAction(action: SetDirtyStateAction): void;
    get sourceUri(): string | undefined;
    get editMode(): string;
    get diagramType(): string;
    get clientId(): string;
    get modelRoot(): Readonly<GModelRoot>;
    get viewport(): Readonly<GModelRoot & Viewport> | undefined;
    get viewportData(): Readonly<Viewport>;
    get canvasBounds(): Readonly<Bounds>;
    get selectedElements(): Readonly<GModelElement>[];
    get isReadonly(): boolean;
    get isDirty(): boolean;
}
export type EditorContextServiceProvider = () => Promise<EditorContextService>;
//# sourceMappingURL=editor-context-service.d.ts.map