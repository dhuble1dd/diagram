/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, GModelElement, GModelRoot, IActionHandler, MoveAction, Point, SetBoundsAction, Vector } from '@eclipse-glsp/sprotty';
import { IFeedbackActionDispatcher } from '../../base/feedback/feedback-action-dispatcher';
import { FeedbackEmitter } from '../../base/feedback/feedback-emitter';
import { ISelectionListener, SelectionService } from '../../base/selection-service';
import { SetBoundsFeedbackAction } from '../bounds/set-bounds-feedback-command';
import { Grid } from '../grid/grid';
import { MoveFinishedEventAction, MoveInitializedEventAction } from '../tools/change-bounds/change-bounds-tool-feedback';
import { AlignmentElementFilter, DrawHelperLinesFeedbackAction, ViewportLineType } from './helper-line-feedback';
import { Direction, HelperLine, HelperLineType } from './model';
export interface IHelperLineManager {
    /**
     * Calculates the minimum move delta on one axis that is necessary to break through a helper line.
     *
     * @param element element that is being moved
     * @param isSnap whether snapping is active or not
     * @param direction direction in which the target element is moving
     */
    getMinimumMoveDelta(element: GModelElement, isSnap: boolean, direction: Direction): number;
    /**
     * Calculates the minimum move vector that is necessary to break through a helper line.
     *
     * @param element element that is being moved
     * @param isSnap whether snapping is active or not
     * @param directions directions in which the target element is moving
     */
    getMinimumMoveVector(element: GModelElement, isSnap: boolean, directions: Direction[]): Vector | undefined;
}
export interface IHelperLineOptions {
    /**
     * A list of helper line types that should be rendered when elements are aligned.
     * Defaults to all possible alignments.
     */
    elementLines?: HelperLineType[];
    /**
     * A list of helper line types that should be rendered when an element is aligned with the viewport.
     * Defaults to middle and center alignment.
     */
    viewportLines?: ViewportLineType[];
    /**
     * The minimum difference between two coordinates
     * Defaults to 1 or zero (perfect match) if the optional grid module is loaded.
     */
    alignmentEpsilon?: number;
    /**
     * A filter that is applied to determine on which elements the alignment calculation is performed.
     * By default all top-level bounds-aware, non-routable elements that are visible on the canvas are considered.
     */
    alignmentElementFilter?: AlignmentElementFilter;
    /**
     * The minimum move delta that is necessary for an element to break through a helper line.
     * Defaults to { x: 1, y: 1 } whereas the x represents the horizontal distance and y represents the vertical distance.
     * If the optional grid module is loaded, defaults to twice the grid size, i.e., two grid moves to break through a helper line.
     */
    minimumMoveDelta?: Point;
    /**
     * Produces debug output.
     * Defaults to false.
     */
    debug?: boolean;
}
export declare const DEFAULT_MOVE_DELTA: {
    x: number;
    y: number;
};
export declare const DEFAULT_HELPER_LINE_OPTIONS: Required<IHelperLineOptions>;
export declare class HelperLineManager implements IActionHandler, ISelectionListener, IHelperLineManager {
    protected feedbackDispatcher: IFeedbackActionDispatcher;
    protected selectionService: SelectionService;
    protected userOptions?: IHelperLineOptions;
    protected grid?: Grid;
    protected options: Required<IHelperLineOptions>;
    protected feedback: FeedbackEmitter;
    protected init(): void;
    handle(action: Action): void;
    protected handleMoveInitializedAction(_action: MoveInitializedEventAction): void;
    protected handleMoveFinishedAction(_action: MoveFinishedEventAction): void;
    protected handleMoveAction(action: MoveAction): void;
    protected submitHelperLineFeedback(elementIds?: string[]): void;
    protected createHelperLineFeedback(elementIds: string[]): DrawHelperLinesFeedbackAction;
    protected handleSetBoundsAction(action: SetBoundsAction | SetBoundsFeedbackAction): void;
    selectionChanged(root: Readonly<GModelRoot>, selectedElements: string[], deselectedElements?: string[] | undefined): void;
    getMinimumMoveDelta(element: GModelElement, isSnap: boolean, direction: Direction): number;
    getMinimumMoveVector(element: GModelElement, isSnap: boolean, move: Direction[]): Vector | undefined;
    protected getHelperLineState(element: GModelElement): HelperLineState;
}
export interface HelperLineState {
    helperLines: HelperLine[];
    types: {
        left: boolean;
        right: boolean;
        top: boolean;
        bottom: boolean;
        center: boolean;
        middle: boolean;
    };
}
//# sourceMappingURL=helper-line-manager.d.ts.map