"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlspHoverMouseListener = void 0;
/********************************************************************************
 * Copyright (c) 2020-2025 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const focus_state_change_action_1 = require("../../base/focus/focus-state-change-action");
const messages_1 = require("../../base/messages");
const tool_1 = require("../../base/tool-manager/tool");
const edge_creation_tool_1 = require("../tools/edge-creation/edge-creation-tool");
const issue_marker_1 = require("../validation/issue-marker");
let GlspHoverMouseListener = class GlspHoverMouseListener extends sprotty_1.HoverMouseListener {
    constructor() {
        super(...arguments);
        this.enableHover = true;
    }
    /**
     * Stops mouse over timer and remove hover feedback, if focus is lost.
     *
     * This fixes strange effects that appear if the mouse left the element via e.g. a context menu,
     * which explicitly removes the focus of the diagram.
     * @see SelectionServiceAwareContextMenuMouseListener
     * @param action should be a `FocusStateChangedAction`
     * @returns a `HoverFeedbackAction` resetting the state, if the specified action indicates lost focus
     */
    handle(action) {
        if (focus_state_change_action_1.FocusStateChangedAction.is(action) && !action.hasFocus) {
            this.stopMouseOverTimer();
            if (this.lastHoverFeedbackElementId) {
                const previousTargetId = this.lastHoverFeedbackElementId;
                this.lastHoverFeedbackElementId = undefined;
                return sprotty_1.HoverFeedbackAction.create({ mouseoverElement: previousTargetId, mouseIsOver: false });
            }
        }
        else if (tool_1.EnableToolsAction.is(action)) {
            this.enableHover = !action.toolIds.includes(edge_creation_tool_1.EdgeCreationTool.ID);
        }
        else if (tool_1.EnableDefaultToolsAction.is(action)) {
            this.enableHover = true;
        }
    }
    mouseOver(target, event) {
        if (this.enableHover) {
            return super.mouseOver(target, event);
        }
        return [];
    }
    startMouseOverTimer(target, event) {
        this.stopMouseOverTimer();
        return new Promise(resolve => {
            this.state.mouseOverTimer = window.setTimeout(() => {
                const popupBounds = this.computePopupBounds(target, { x: event.pageX, y: event.pageY });
                if (target instanceof issue_marker_1.GIssueMarker) {
                    resolve(sprotty_1.SetPopupModelAction.create(this.createPopupModel(target, popupBounds)));
                }
                else {
                    resolve(sprotty_1.RequestPopupModelAction.create({ elementId: target.id, bounds: popupBounds }));
                }
                this.state.popupOpen = true;
                this.state.previousPopupElement = target;
            }, this.options.popupOpenDelay);
        });
    }
    createPopupModel(marker, bounds) {
        if (marker.issues !== undefined && marker.issues.length > 0) {
            return {
                type: 'html',
                id: 'sprotty-popup',
                children: [this.createMarkerIssuePopup(marker)],
                canvasBounds: this.modifyBounds(bounds)
            };
        }
        return { type: sprotty_1.EMPTY_ROOT.type, id: sprotty_1.EMPTY_ROOT.id };
    }
    createMarkerIssuePopup(marker) {
        const message = this.createIssueMessage(marker);
        return {
            type: 'pre-rendered',
            id: 'popup-title',
            code: `<div class="${(0, issue_marker_1.getSeverity)(marker)}"><div class="sprotty-popup-title">${message}</div></div>`
        };
    }
    createIssueMessage(marker) {
        return '<ul>' + marker.issues.map(i => '<li>' + this.getSeverityString(i.severity) + ': ' + i.message + '</li>').join('') + '</ul>';
    }
    getSeverityString(severity) {
        switch (severity) {
            case 'error':
                return messages_1.messages.issue_marker.severity_error;
            case 'warning':
                return messages_1.messages.issue_marker.severity_warning;
            case 'info':
                return messages_1.messages.issue_marker.severity_info;
        }
    }
    modifyBounds(bounds) {
        return bounds;
    }
};
exports.GlspHoverMouseListener = GlspHoverMouseListener;
exports.GlspHoverMouseListener = GlspHoverMouseListener = __decorate([
    (0, inversify_1.injectable)()
], GlspHoverMouseListener);
//# sourceMappingURL=hover.js.map