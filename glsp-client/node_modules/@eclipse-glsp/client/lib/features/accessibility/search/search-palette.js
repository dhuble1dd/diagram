"use strict";
/********************************************************************************
 * Copyright (c) 2023-2025 Business Informatics Group (TU Wien) and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SearchAutocompletePalette_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchAutocompletePalette = exports.RevealEdgeElementAutocompleteSuggestionProvider = exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = exports.RevealNamedElementAutocompleteSuggestionProvider = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const lodash_1 = require("lodash");
const base_autocomplete_palette_1 = require("../../../base/auto-complete/base-autocomplete-palette");
const css_feedback_1 = require("../../../base/feedback/css-feedback");
const messages_1 = require("../../../base/messages");
const reposition_1 = require("../../../features/viewport/reposition");
const model_1 = require("../../../model");
const CSS_SEARCH_HIDDEN = 'search-hidden';
const CSS_SEARCH_HIGHLIGHTED = 'search-highlighted';
class RevealNamedElementAutocompleteSuggestionProvider {
    async retrieveSuggestions(root, text) {
        const nameables = (0, sprotty_1.toArray)(root.index.all().filter(element => (0, sprotty_1.isNameable)(element)));
        return nameables.map(nameable => {
            var _a;
            return ({
                element: nameable,
                action: {
                    label: `[${nameable.type}] ${(_a = (0, sprotty_1.name)(nameable)) !== null && _a !== void 0 ? _a : '<no-name>'}`,
                    actions: this.getActions(nameable),
                    icon: (0, sprotty_1.codiconCSSString)('eye')
                }
            });
        });
    }
    getActions(nameable) {
        return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
    }
}
exports.RevealNamedElementAutocompleteSuggestionProvider = RevealNamedElementAutocompleteSuggestionProvider;
class RevealNodesWithoutNameAutocompleteSuggestionProvider {
    async retrieveSuggestions(root, text) {
        const nodes = (0, sprotty_1.toArray)(root.index.all().filter(element => !(0, sprotty_1.isNameable)(element) && element instanceof sprotty_1.GNode));
        return nodes.map(node => ({
            element: node,
            action: {
                label: `[${node.type}]`,
                actions: this.getActions(node),
                icon: (0, sprotty_1.codiconCSSString)('symbol-namespace')
            }
        }));
    }
    getActions(nameable) {
        return [sprotty_1.SelectAction.create({ selectedElementsIDs: [nameable.id] }), sprotty_1.CenterAction.create([nameable.id], { retainZoom: true })];
    }
}
exports.RevealNodesWithoutNameAutocompleteSuggestionProvider = RevealNodesWithoutNameAutocompleteSuggestionProvider;
class RevealEdgeElementAutocompleteSuggestionProvider {
    async retrieveSuggestions(root, text) {
        const edges = (0, sprotty_1.toArray)(root.index.all().filter(element => element instanceof model_1.GEdge));
        return edges.map(edge => ({
            element: edge,
            action: {
                label: `[${edge.type}]  ${this.getEdgeLabel(root, edge)}`,
                actions: this.getActions(edge),
                icon: (0, sprotty_1.codiconCSSString)('arrow-both')
            }
        }));
    }
    getActions(edge) {
        return [sprotty_1.SelectAction.create({ selectedElementsIDs: [edge.id] }), sprotty_1.CenterAction.create([edge.sourceId, edge.targetId])];
    }
    getEdgeLabel(root, edge) {
        var _a, _b;
        let sourceName = '';
        let targetName = '';
        const sourceNode = root.index.getById(edge.sourceId);
        const targetNode = root.index.getById(edge.targetId);
        if (sourceNode !== undefined) {
            sourceName = (_a = (0, sprotty_1.name)(sourceNode)) !== null && _a !== void 0 ? _a : sourceNode.type;
        }
        if (targetNode !== undefined) {
            targetName = (_b = (0, sprotty_1.name)(targetNode)) !== null && _b !== void 0 ? _b : targetNode.type;
        }
        return sourceName + ' -> ' + targetName;
    }
}
exports.RevealEdgeElementAutocompleteSuggestionProvider = RevealEdgeElementAutocompleteSuggestionProvider;
let SearchAutocompletePalette = SearchAutocompletePalette_1 = class SearchAutocompletePalette extends base_autocomplete_palette_1.BaseAutocompletePalette {
    constructor() {
        super(...arguments);
        this.cachedSuggestions = [];
    }
    id() {
        return SearchAutocompletePalette_1.ID;
    }
    initializeContents(containerElement) {
        super.initializeContents(containerElement);
        this.autocompleteWidget.inputField.placeholder = messages_1.messages.search.placeholder;
        containerElement.setAttribute('aria-label', messages_1.messages.search.label);
    }
    getSuggestionProviders(root, input) {
        return [
            new RevealNamedElementAutocompleteSuggestionProvider(),
            new RevealEdgeElementAutocompleteSuggestionProvider(),
            new RevealNodesWithoutNameAutocompleteSuggestionProvider()
        ];
    }
    async retrieveSuggestions(root, input) {
        const providers = this.getSuggestionProviders(root, input);
        const suggestions = (await Promise.all(providers.map(provider => provider.retrieveSuggestions(root, input)))).flat(1);
        this.cachedSuggestions = suggestions;
        return suggestions.map(s => s.action);
    }
    async visibleSuggestionsChanged(root, labeledActions) {
        await this.applyCSS(this.getHiddenElements(root, this.getSuggestionsFromLabeledActions(labeledActions)), CSS_SEARCH_HIDDEN);
        await this.deleteCSS(this.getSuggestionsFromLabeledActions(labeledActions).map(s => s.element), CSS_SEARCH_HIDDEN);
    }
    async selectedSuggestionChanged(root, labeledAction) {
        await this.deleteAllCSS(root, CSS_SEARCH_HIGHLIGHTED);
        if (labeledAction !== undefined) {
            const suggestions = this.getSuggestionsFromLabeledActions([labeledAction]);
            const actions = [];
            suggestions.map(currElem => actions.push(reposition_1.RepositionAction.create([currElem.element.id])));
            this.actionDispatcher.dispatchAll(actions);
            await this.applyCSS(suggestions.map(s => s.element), CSS_SEARCH_HIGHLIGHTED);
        }
    }
    show(root, ...contextElementIds) {
        this.actionDispatcher.dispatch(sprotty_1.SelectAllAction.create(false));
        super.show(root, ...contextElementIds);
    }
    hide() {
        if (this.root !== undefined) {
            this.deleteAllCSS(this.root, CSS_SEARCH_HIDDEN);
            this.deleteAllCSS(this.root, CSS_SEARCH_HIGHLIGHTED);
            this.autocompleteWidget.inputField.value = '';
        }
        super.hide();
    }
    applyCSS(elements, cssClass) {
        const actions = elements.map(element => (0, css_feedback_1.applyCssClasses)(element, cssClass));
        return this.actionDispatcher.dispatchAll(actions);
    }
    deleteCSS(elements, cssClass) {
        const actions = elements.map(element => (0, css_feedback_1.deleteCssClasses)(element, cssClass));
        return this.actionDispatcher.dispatchAll(actions);
    }
    deleteAllCSS(root, cssClass) {
        const actions = (0, sprotty_1.toArray)(root.index.all().map(element => (0, css_feedback_1.deleteCssClasses)(element, cssClass)));
        return this.actionDispatcher.dispatchAll(actions);
    }
    getSuggestionsFromLabeledActions(labeledActions) {
        return this.cachedSuggestions.filter(c => labeledActions.find(s => (0, lodash_1.isEqual)(s, c.action)));
    }
    getHiddenSuggestionsFromLabeledActions(labeledActions) {
        return this.cachedSuggestions.filter(c => !labeledActions.find(s => (0, lodash_1.isEqual)(s, c.action)));
    }
    getHiddenElements(root, suggestions) {
        return (0, sprotty_1.toArray)(root.index
            .all()
            .filter(element => element instanceof sprotty_1.GNode || element instanceof model_1.GEdge)
            .filter(element => suggestions.find(suggestion => suggestion.element.id === element.id) === undefined));
    }
};
exports.SearchAutocompletePalette = SearchAutocompletePalette;
SearchAutocompletePalette.ID = 'search-autocomplete-palette';
exports.SearchAutocompletePalette = SearchAutocompletePalette = SearchAutocompletePalette_1 = __decorate([
    (0, inversify_1.injectable)()
], SearchAutocompletePalette);
//# sourceMappingURL=search-palette.js.map