"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PossibleEdgeTargetAutocompleteSuggestionProvider = exports.EdgeAutocompletePalette = exports.EdgeAutocompletePaletteMetadata = void 0;
/********************************************************************************
 * Copyright (c) 2023-2024 Business Informatics Group (TU Wien) and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const auto_complete_widget_1 = require("../../../base/auto-complete/auto-complete-widget");
const tool_1 = require("../../../base/tool-manager/tool");
const model_1 = require("../../../model");
const search_palette_1 = require("../search/search-palette");
const action_1 = require("./action");
var EdgeAutocompletePaletteMetadata;
(function (EdgeAutocompletePaletteMetadata) {
    EdgeAutocompletePaletteMetadata.ID = 'edge-autocomplete-palette';
})(EdgeAutocompletePaletteMetadata || (exports.EdgeAutocompletePaletteMetadata = EdgeAutocompletePaletteMetadata = {}));
let EdgeAutocompletePalette = class EdgeAutocompletePalette extends search_palette_1.SearchAutocompletePalette {
    constructor() {
        super(...arguments);
        this.targetSuggestionProvider = new PossibleEdgeTargetAutocompleteSuggestionProvider();
    }
    id() {
        return EdgeAutocompletePaletteMetadata.ID;
    }
    handle(action) {
        if (sprotty_1.TriggerEdgeCreationAction.is(action)) {
            this.context = {
                trigger: action,
                role: 'source'
            };
            this.targetSuggestionProvider.setContext(action, this.context);
        }
    }
    onBeforeShow(containerElement, root, ...contextElementIds) {
        var _a;
        super.onBeforeShow(containerElement, root, ...contextElementIds);
        this.autocompleteWidget.inputField.placeholder = `Search for ${(_a = this.context) === null || _a === void 0 ? void 0 : _a.role} elements`;
    }
    getSuggestionProviders(root, input) {
        return [this.targetSuggestionProvider];
    }
    reload() {
        const context = this.context;
        this.hide();
        this.context = context;
        this.actionDispatcher.dispatch(sprotty_1.SetUIExtensionVisibilityAction.create({
            extensionId: EdgeAutocompletePaletteMetadata.ID,
            visible: true
        }));
    }
    executeSuggestion(input) {
        var _a, _b, _c, _d;
        const action = (0, auto_complete_widget_1.toActionArray)(input)[0];
        if (((_a = this.context) === null || _a === void 0 ? void 0 : _a.role) === 'source') {
            this.context.sourceId = action.elementId;
            this.context.role = 'target';
            this.reload();
        }
        else if (((_b = this.context) === null || _b === void 0 ? void 0 : _b.role) === 'target') {
            this.context.targetId = action.elementId;
        }
        if (((_c = this.context) === null || _c === void 0 ? void 0 : _c.sourceId) !== undefined && ((_d = this.context) === null || _d === void 0 ? void 0 : _d.targetId) !== undefined) {
            this.actionDispatcher.dispatchAll([
                sprotty_1.CreateEdgeOperation.create({
                    elementTypeId: this.context.trigger.elementTypeId,
                    sourceElementId: this.context.sourceId,
                    targetElementId: this.context.targetId,
                    args: this.context.trigger.args
                }),
                tool_1.EnableDefaultToolsAction.create()
            ]);
            this.hide();
        }
    }
    autocompleteHide(reason) {
        if (reason !== 'submission') {
            this.hide();
        }
    }
};
exports.EdgeAutocompletePalette = EdgeAutocompletePalette;
exports.EdgeAutocompletePalette = EdgeAutocompletePalette = __decorate([
    (0, inversify_1.injectable)()
], EdgeAutocompletePalette);
let PossibleEdgeTargetAutocompleteSuggestionProvider = class PossibleEdgeTargetAutocompleteSuggestionProvider {
    setContext(triggerAction, edgeAutocompleteContext) {
        this.proxyEdge = new model_1.GEdge();
        this.proxyEdge.type = triggerAction.elementTypeId;
        this.context = edgeAutocompleteContext;
    }
    isAllowedSource(element, role) {
        return element !== undefined && this.proxyEdge !== undefined && (0, sprotty_1.isConnectable)(element) && element.canConnect(this.proxyEdge, role);
    }
    async retrieveSuggestions(root, text) {
        const context = this.context;
        if (this.context === undefined) {
            return [];
        }
        const nodes = (0, sprotty_1.toArray)(root.index.all().filter(element => this.isAllowedSource(element, context.role)));
        return nodes.map(node => {
            var _a;
            return ({
                element: node,
                action: {
                    label: `[${node.type}] ${(_a = (0, sprotty_1.name)(node)) !== null && _a !== void 0 ? _a : '<no-name>'}`,
                    actions: [action_1.SetEdgeTargetSelectionAction.create(node.id, context.role)],
                    icon: (0, sprotty_1.codiconCSSString)('arrow-both')
                }
            });
        });
    }
};
exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider;
exports.PossibleEdgeTargetAutocompleteSuggestionProvider = PossibleEdgeTargetAutocompleteSuggestionProvider = __decorate([
    (0, inversify_1.injectable)()
], PossibleEdgeTargetAutocompleteSuggestionProvider);
//# sourceMappingURL=edge-autocomplete-palette.js.map