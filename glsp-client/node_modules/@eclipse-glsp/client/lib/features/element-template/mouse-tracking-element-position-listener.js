"use strict";
/********************************************************************************
 * Copyright (c) 2023-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseTrackingElementPositionListener = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const drag_aware_mouse_listener_1 = require("../../base/drag-aware-mouse-listener");
const css_feedback_1 = require("../../base/feedback/css-feedback");
const viewpoint_util_1 = require("../../utils/viewpoint-util");
const change_bounds_tool_feedback_1 = require("../tools/change-bounds/change-bounds-tool-feedback");
class MouseTrackingElementPositionListener extends drag_aware_mouse_listener_1.DragAwareMouseListener {
    constructor(elementId, tool, cursorPosition = 'top-left', editorContext) {
        super();
        this.elementId = elementId;
        this.tool = tool;
        this.cursorPosition = cursorPosition;
        this.editorContext = editorContext;
        this.toDispose = new sprotty_1.DisposableCollection();
        this.tracker = this.tool.changeBoundsManager.createTracker();
        this.moveGhostFeedback = this.tool.createFeedbackEmitter();
        this.toDispose.push(this.moveGhostFeedback);
        const modelRootChangedListener = editorContext === null || editorContext === void 0 ? void 0 : editorContext.onModelRootChanged(newRoot => this.modelRootChanged(newRoot));
        if (modelRootChangedListener) {
            this.toDispose.push(modelRootChangedListener);
        }
    }
    getTrackedElement(target, event) {
        const element = target.root.index.getById(this.elementId);
        return !element || !(0, sprotty_1.isMoveable)(element) ? undefined : element;
    }
    mouseMove(ctx, event) {
        super.mouseMove(ctx, event);
        const element = this.getTrackedElement(ctx, event);
        if (!element) {
            return [];
        }
        const isInitializing = !this.tracker.isTracking();
        if (isInitializing) {
            this.initialize(element, ctx, event);
        }
        const move = this.tracker.moveElements([element], { snap: event, restrict: event, skipStatic: !isInitializing });
        const elementMove = move.elementMoves[0];
        if (!elementMove) {
            return [];
        }
        // since we are moving a ghost element that is feedback-only and will be removed anyway,
        // we just send a MoveFinishedEventAction instead of reseting the position with a MoveAction and the finished flag set to true.
        this.moveGhostFeedback.add(sprotty_1.MoveAction.create([{ elementId: this.elementId, toPosition: elementMove.toPosition }], { animate: false }), change_bounds_tool_feedback_1.MoveFinishedEventAction.create());
        this.addMoveFeedback(move, ctx, event);
        this.moveGhostFeedback.submit();
        this.tracker.updateTrackingPosition(elementMove.moveVector);
        return [];
    }
    initialize(element, target, event) {
        this.tracker.startTracking();
        element.position = this.initializeElementPosition(element, target, event);
    }
    initializeElementPosition(element, target, event) {
        const mousePosition = (0, viewpoint_util_1.getAbsolutePosition)(target, event);
        return this.cursorPosition === 'middle' && (0, sprotty_1.isBoundsAware)(element)
            ? sprotty_1.Point.subtract(mousePosition, sprotty_1.Dimension.center(element.bounds))
            : mousePosition;
    }
    addMoveFeedback(move, ctx, event) {
        this.moveGhostFeedback.add(css_feedback_1.ModifyCSSFeedbackAction.create({ elements: [this.elementId], remove: [css_feedback_1.CSS_HIDDEN] }));
        this.tool.changeBoundsManager.addMoveFeedback(this.moveGhostFeedback, move, ctx, event);
    }
    modelRootChanged(root) {
        // stop the tracking once we receive a new model root and ensure proper alignment with next next mouse move
        this.tracker.stopTracking();
    }
    dispose() {
        this.toDispose.dispose();
        super.dispose();
    }
}
exports.MouseTrackingElementPositionListener = MouseTrackingElementPositionListener;
//# sourceMappingURL=mouse-tracking-element-position-listener.js.map