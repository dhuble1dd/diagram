"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatefulLayouterExt = exports.LayouterExt = void 0;
/********************************************************************************
 * Copyright (c) 2022-2023 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const inversify_1 = require("inversify");
const sprotty_1 = require("@eclipse-glsp/sprotty");
let LayouterExt = class LayouterExt extends sprotty_1.Layouter {
    layout(element2boundsData) {
        new StatefulLayouterExt(element2boundsData, this.layoutRegistry, this.logger).layout();
    }
};
exports.LayouterExt = LayouterExt;
exports.LayouterExt = LayouterExt = __decorate([
    (0, inversify_1.injectable)()
], LayouterExt);
// 2-pass layout:
// Step 1: Find "rendered size" of each element (may take resizeContainer into account)
// Child-to-parent layout
// Step 2: Extend parents as necessary, then use the adjusted parent size to properly
// align children (center/end alignments, hGrab/vGrab)
// Parent-to-children layout
class StatefulLayouterExt extends sprotty_1.StatefulLayouter {
    /**
     *
     * @param elementToBoundsData The map of element to bounds data. Bounds Data are computed from the hidden
     * SVG rendering pass.
     * @param layoutRegistry2 The registry of available layouts.
     * @param log The log.
     */
    constructor(elementToBoundsData, layoutRegistry2, log) {
        super(elementToBoundsData, layoutRegistry2, log);
        this.elementToBoundsData = elementToBoundsData;
        this.layoutRegistry2 = layoutRegistry2;
        this.toBeLayouted2 = [];
        elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
                this.toBeLayouted2.push(element);
            }
        });
        for (const element of this.toBeLayouted2) {
            // Clear previous layout information for dynamic-layout objects
            elementToBoundsData.delete(element);
        }
    }
    getBoundsData(element) {
        let boundsData = this.elementToBoundsData.get(element);
        let bounds = element.bounds;
        if ((0, sprotty_1.isLayoutContainer)(element) && this.toBeLayouted2.indexOf(element) >= 0) {
            bounds = this.doLayout(element);
        }
        else if ((0, sprotty_1.isLayoutContainer)(element)) {
            bounds = {
                x: 0,
                y: 0,
                width: -1,
                height: -1
            };
        }
        if (!boundsData) {
            boundsData = {
                bounds: bounds,
                boundsChanged: false,
                alignmentChanged: false
            };
            this.elementToBoundsData.set(element, boundsData);
        }
        return boundsData;
    }
    layout() {
        // First pass: apply layout with cleared container data. Will get
        // preferred size for all elements (Children first, then parents)
        while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
        }
        this.toBeLayouted2 = [];
        this.elementToBoundsData.forEach((data, element) => {
            if ((0, sprotty_1.isLayoutContainer)(element)) {
                this.toBeLayouted2.push(element);
            }
        });
        // Second pass: apply layout with initial size data for all
        // nodes. Update the position/size of all elements, taking
        // vGrab/hGrab into account (parent -> children).
        while (this.toBeLayouted2.length > 0) {
            const element = this.toBeLayouted2[0];
            this.doLayout(element);
        }
    }
    doLayout(element) {
        const index = this.toBeLayouted2.indexOf(element);
        if (index >= 0) {
            this.toBeLayouted2.splice(index, 1);
        }
        const layout = this.layoutRegistry2.get(element.layout);
        if (layout) {
            layout.layout(element, this);
        }
        const boundsData = this.elementToBoundsData.get(element);
        if (boundsData !== undefined && boundsData.bounds !== undefined) {
            return boundsData.bounds;
        }
        else {
            this.log.error(element, 'Layout failed');
            return sprotty_1.Bounds.EMPTY;
        }
    }
}
exports.StatefulLayouterExt = StatefulLayouterExt;
//# sourceMappingURL=layouter.js.map