"use strict";
/********************************************************************************
 * Copyright (c) 2020-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable import/no-deprecated */
/* eslint-disable deprecation/deprecation */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointPositionUpdater = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const gmodel_util_1 = require("../../utils/gmodel-util");
const html_utils_1 = require("../../utils/html-utils");
const model_1 = require("../helper-lines/model");
const position_snapper_1 = require("./position-snapper");
const snap_1 = require("./snap");
/**
 * This class can be used to calculate the current position, when an element is
 * moved. This includes node movements, node resizing (resize handle movement)
 * or edge routing-point movements.
 *
 * You can initialize a this class with a optional {@link ISnapper}. If a
 * snapper is present, the positions will be snapped to the defined grid.
 *
 * @deprecated The use of this class is discouraged. Use the {@link ChangeBoundsManager.createTracker}
 * instead which centralized a few aspects of the tracking.
 */
class PointPositionUpdater {
    constructor(first, helperLineManager) {
        this.positionDelta = { x: 0, y: 0 };
        this.positionSnapper = first instanceof position_snapper_1.PositionSnapper ? first : new position_snapper_1.PositionSnapper(first, helperLineManager);
    }
    updateLastDragPosition(first) {
        this.lastDragPosition = (0, html_utils_1.isMouseEvent)(first) ? { x: first.pageX, y: first.pageY } : first;
    }
    /**
     * Check if the mouse is currently not in a drag mode.
     * @returns true if the last drag position is undefined
     */
    isLastDragPositionUndefined() {
        return this.lastDragPosition === undefined;
    }
    /**
     * Reset the updater for new movements.
     * This method is normally called in the `mouseUp` event.
     */
    resetPosition() {
        this.lastDragPosition = undefined;
        this.positionDelta = { x: 0, y: 0 };
    }
    updatePosition(target, second, third, fourth) {
        if (!this.lastDragPosition) {
            return undefined;
        }
        const mousePosition = (0, html_utils_1.isMouseEvent)(second) ? { x: second.pageX, y: second.pageY } : second;
        const shouldSnap = typeof third === 'boolean' ? third : (0, snap_1.useSnap)(second);
        const direction = typeof third !== 'boolean' ? third : fourth;
        // calculate update to last drag position
        const deltaToLastPosition = (0, gmodel_util_1.calculateDeltaBetweenPoints)(mousePosition, this.lastDragPosition, target);
        this.lastDragPosition = mousePosition;
        if (sprotty_1.Point.equals(deltaToLastPosition, sprotty_1.Point.ORIGIN)) {
            return undefined;
        }
        // accumulate position delta with latest delta
        this.positionDelta.x += deltaToLastPosition.x;
        this.positionDelta.y += deltaToLastPosition.y;
        const directions = direction !== null && direction !== void 0 ? direction : (0, model_1.getDirectionOf)(this.positionDelta);
        // only send update if the position actually changes
        // otherwise accumulate delta until we get to an update
        const positionUpdate = this.positionSnapper.snapDelta(this.positionDelta, target, shouldSnap, directions);
        if (sprotty_1.Point.equals(positionUpdate, sprotty_1.Point.ORIGIN)) {
            return undefined;
        }
        // we update our position so we update our delta by the snapped position
        this.positionDelta.x -= positionUpdate.x;
        this.positionDelta.y -= positionUpdate.y;
        return positionUpdate;
    }
}
exports.PointPositionUpdater = PointPositionUpdater;
//# sourceMappingURL=point-position-updater.js.map