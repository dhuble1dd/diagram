/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Action, CommandExecutionContext, Connectable, EdgeTypeHint, GModelElement, GModelElementSchema, GModelRoot, GRoutableElement, IActionDispatcher, IActionHandler, SetTypeHintsAction, ShapeTypeHint, TypeHint } from '@eclipse-glsp/sprotty';
import { IFeedbackActionDispatcher } from '../../base/feedback/feedback-action-dispatcher';
import { FeedbackCommand } from '../../base/feedback/feedback-command';
import { FeedbackEmitter } from '../../base/feedback/feedback-emitter';
import { IDiagramStartup } from '../../base/model/diagram-loader';
/**
 * Is dispatched by the {@link TypeHintProvider} to apply the type hints received from the server
 * onto the graphical model. The action is dispatched as persistent feedback to ensure the applied type hints
 * don't get lost after a server-side model update.
 */
export interface ApplyTypeHintsAction extends Action {
    kind: typeof ApplyTypeHintsAction.KIND;
}
export declare namespace ApplyTypeHintsAction {
    const KIND = "applyTypeHints";
    function is(object: any): object is ApplyTypeHintsAction;
    function create(): ApplyTypeHintsAction;
}
type CanConnectFn = Connectable['canConnect'];
/**
 * Command that processes the entire model and for each model element applies its
 * type hints i.e. translates the type hint information into corresponding model features
 * and adds/removes them from the model element.
 */
export declare class ApplyTypeHintsCommand extends FeedbackCommand {
    protected action: ApplyTypeHintsAction;
    static KIND: string;
    readonly rank: number;
    protected typeHintProvider: ITypeHintProvider;
    constructor(action: ApplyTypeHintsAction);
    execute(context: CommandExecutionContext): GModelRoot;
    protected applyEdgeTypeHint(element: GModelElement): void;
    protected applyShapeTypeHint(element: GModelElement): void;
    /**
     * Type hints aware wrapper function for  `Connectable.canConnect`. After type hints have been applied
     * the `canConnect` implementation of `connectable` model elements  (with a matching hint) will forward to this method.
     */
    protected canConnect(routable: GRoutableElement, role: 'source' | 'target', element: GModelElement, fallbackCanConnect?: CanConnectFn): boolean;
    /**
     * Type hints aware wrapper function for  `Containable.isContainableElement`. After type hints have been applied
     * the `isContainableElement` implementation of `containable` model elements (with a matching hint) will forward to this method.
     */
    protected isContainableElement(input: GModelElement | GModelElementSchema | string, hint: ShapeTypeHint): boolean;
}
/**
 * Provides query methods for retrieving the type hint that is applicable for a given model element.
 * If there is no type hint registered for the given element type the hint of the most concrete subtype (if any)
 * is returned instead. Subtypes are declared with a `:` delimiter.
 * For example consider the type `node:task:manual`. Then the provider fist checks wether there is
 * a type hint registered for `node:task:manual`. If not it checks wether there is one registered
 * for `node:task` and finally it checks wether there is a type hint for `node`.
 */
export interface ITypeHintProvider {
    /**
     * Retrieve the most applicable {@link ShapeTypeHint} for the given model element.
     *
     * @param input The model element whose type hint should be retrieved
     * @returns The most applicable hint of the given element or `undefined` if no matching hint is registered.
     */
    getShapeTypeHint(input: GModelElement | GModelElementSchema | string): ShapeTypeHint | undefined;
    /**
     * Retrieve the most applicable {@link EdgeTypeHint} for the given model element.
     *
     * @param input The model element whose type hint should be retrieved
     * @returns The most applicable hint of the given element or `undefined` if no matching hint is registered.
     */
    getEdgeTypeHint(input: GModelElement | GModelElementSchema | string): EdgeTypeHint | undefined;
}
export declare class TypeHintProvider implements IActionHandler, ITypeHintProvider, IDiagramStartup {
    protected feedbackActionDispatcher: IFeedbackActionDispatcher;
    protected actionDispatcher: IActionDispatcher;
    protected typeHintsFeedback: FeedbackEmitter;
    protected shapeHints: Map<string, ShapeTypeHint>;
    protected edgeHints: Map<string, EdgeTypeHint>;
    protected init(): void;
    handle(action: SetTypeHintsAction): void;
    getShapeTypeHint(input: GModelElement | GModelElementSchema | string): ShapeTypeHint | undefined;
    getEdgeTypeHint(input: GModelElement | GModelElementSchema | string): EdgeTypeHint | undefined;
    protected getTypeHint<T extends TypeHint>(input: GModelElement | GModelElementSchema | string, hints: Map<string, T>): T | undefined;
    postRequestModel(): Promise<void>;
}
export {};
//# sourceMappingURL=type-hint-provider.d.ts.map