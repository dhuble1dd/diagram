"use strict";
/********************************************************************************
 * Copyright (c) 2021-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarqueeUtil = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const model_1 = require("../../../model");
const gmodel_util_1 = require("../../../utils/gmodel-util");
const viewpoint_util_1 = require("../../../utils/viewpoint-util");
const marquee_tool_feedback_1 = require("./marquee-tool-feedback");
let MarqueeUtil = class MarqueeUtil {
    constructor(marqueeBehavior = { entireElement: false, entireEdge: false }, domHelper) {
        this.marqueeBehavior = marqueeBehavior;
        this.domHelper = domHelper;
    }
    isContinuousMode(element, event) {
        return event.shiftKey;
    }
    getMarkableNodes(root) {
        return (0, gmodel_util_1.getMatchingElements)(root.index, this.isMarkableNode());
    }
    isMarkableNode() {
        return (0, sprotty_1.typeGuard)((0, sprotty_1.toTypeGuard)(sprotty_1.GNode), gmodel_util_1.isSelectableAndBoundsAware);
    }
    getMarkableEdges(root) {
        return (0, gmodel_util_1.getMatchingElements)(root.index, this.isMarkableEdge());
    }
    isMarkableEdge() {
        return (0, sprotty_1.typeGuard)((0, sprotty_1.toTypeGuard)(model_1.GEdge), sprotty_1.isSelectable);
    }
    updateStartPoint(position) {
        this.startPoint = position;
    }
    updateCurrentPoint(position) {
        this.currentPoint = position;
    }
    isMarked(element) {
        return element instanceof model_1.GEdge ? this.isMarkedEdge(element) : this.isMarkedNode(element);
    }
    drawMarqueeAction() {
        return marquee_tool_feedback_1.DrawMarqueeAction.create({ startPoint: this.startPoint, endPoint: this.currentPoint });
    }
    isMarkedEdge(edge) {
        const domId = this.domHelper.createUniqueDOMElementId(edge);
        const domEdge = document.getElementById(domId);
        if (!domEdge || domEdge.getAttribute('transform') || !domEdge.children[0]) {
            return false;
        }
        const path = domEdge.children[0].getAttribute('d');
        return this.isEdgePathMarked(path);
    }
    isMarkedNode(node) {
        return this.isNodeMarked(this.getNodeBounds(node));
    }
    getNodeBounds(node) {
        return (0, viewpoint_util_1.toAbsoluteBounds)(node);
    }
    isEdgePathMarked(path) {
        if (!path) {
            return false;
        }
        const points = path
            .split(/M|L/)
            .filter(p => p)
            .map(p => {
            const coord = p.split(',');
            return { x: parseInt(coord[0], 10), y: parseInt(coord[1], 10) };
        });
        return this.isEdgeMarked(points);
    }
    isEdgeMarked(points) {
        return this.marqueeBehavior.entireEdge ? this.isEntireEdgeMarked(points) : this.isPartOfEdgeMarked(points);
    }
    isNodeMarked(elementBounds) {
        const horizontallyIn = this.startPoint.x < this.currentPoint.x
            ? this.isElementBetweenXAxis(elementBounds, this.startPoint.x, this.currentPoint.x)
            : this.isElementBetweenXAxis(elementBounds, this.currentPoint.x, this.startPoint.x);
        const verticallyIn = this.startPoint.y < this.currentPoint.y
            ? this.isElementBetweenYAxis(elementBounds, this.startPoint.y, this.currentPoint.y)
            : this.isElementBetweenYAxis(elementBounds, this.currentPoint.y, this.startPoint.y);
        return horizontallyIn && verticallyIn;
    }
    isEntireEdgeMarked(points) {
        for (let i = 0; i < points.length; i++) {
            if (!this.pointInRect(points[i])) {
                return false;
            }
        }
        return true;
    }
    isPartOfEdgeMarked(points) {
        for (let i = 0; i < points.length - 1; i++) {
            if (this.isLineMarked(points[i], points[i + 1])) {
                return true;
            }
        }
        return false;
    }
    isLineMarked(point1, point2) {
        const line = new sprotty_1.PointToPointLine(point1, point2);
        return (this.pointInRect(point1) ||
            this.pointInRect(point2) ||
            this.lineIntersect(line, this.startPoint, { x: this.startPoint.x, y: this.currentPoint.y }) ||
            this.lineIntersect(line, this.startPoint, { x: this.currentPoint.x, y: this.startPoint.y }) ||
            this.lineIntersect(line, { x: this.currentPoint.x, y: this.startPoint.y }, this.currentPoint) ||
            this.lineIntersect(line, { x: this.startPoint.x, y: this.currentPoint.y }, this.currentPoint));
    }
    lineIntersect(line, p1, p2) {
        return line.intersection(new sprotty_1.PointToPointLine(p1, p2)) !== undefined;
    }
    pointInRect(point) {
        const boolX = this.startPoint.x <= this.currentPoint.x
            ? this.isBetween(point.x, this.startPoint.x, this.currentPoint.x)
            : this.isBetween(point.x, this.currentPoint.x, this.startPoint.x);
        const boolY = this.startPoint.y <= this.currentPoint.y
            ? this.isBetween(point.y, this.startPoint.y, this.currentPoint.y)
            : this.isBetween(point.y, this.currentPoint.y, this.startPoint.y);
        return boolX && boolY;
    }
    isElementBetweenXAxis(elementBounds, marqueeLeft, marqueeRight) {
        const leftEdge = this.isBetween(elementBounds.x, marqueeLeft, marqueeRight);
        const rightEdge = this.isBetween(elementBounds.x + elementBounds.width, marqueeLeft, marqueeRight);
        if (this.marqueeBehavior.entireElement) {
            return leftEdge && rightEdge;
        }
        return (leftEdge ||
            rightEdge ||
            this.isBetween(marqueeLeft, elementBounds.x, elementBounds.x + elementBounds.width) ||
            this.isBetween(marqueeRight, elementBounds.x, elementBounds.x + elementBounds.width));
    }
    isElementBetweenYAxis(elementBounds, marqueeTop, marqueeBottom) {
        const topEdge = this.isBetween(elementBounds.y, marqueeTop, marqueeBottom);
        const bottomEdge = this.isBetween(elementBounds.y + elementBounds.height, marqueeTop, marqueeBottom);
        if (this.marqueeBehavior.entireElement) {
            return topEdge && bottomEdge;
        }
        return (topEdge ||
            bottomEdge ||
            this.isBetween(marqueeTop, elementBounds.y, elementBounds.y + elementBounds.height) ||
            this.isBetween(marqueeBottom, elementBounds.y, elementBounds.y + elementBounds.height));
    }
    isBetween(x, lower, upper) {
        return lower <= x && x <= upper;
    }
};
exports.MarqueeUtil = MarqueeUtil;
exports.MarqueeUtil = MarqueeUtil = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.IMarqueeBehavior)),
    __param(0, (0, inversify_1.optional)()),
    __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.DOMHelper)),
    __metadata("design:paramtypes", [Object, sprotty_1.DOMHelper])
], MarqueeUtil);
//# sourceMappingURL=marquee-behavior.js.map