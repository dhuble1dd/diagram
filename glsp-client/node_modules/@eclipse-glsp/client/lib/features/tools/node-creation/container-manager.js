"use strict";
/********************************************************************************
 * Copyright (c) 2024-2025 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerManager = exports.DEFAULT_INSERT_OPTIONS = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const css_feedback_1 = require("../../../base/feedback/css-feedback");
const model_1 = require("../../hints/model");
exports.DEFAULT_INSERT_OPTIONS = {
    validateLocationInContainer: false
};
/**
 * The default {@link IContainerManager} implementation.
 * This class class manages the insertion of elements into containers by validating their positions and types,
 * providing feedback on the insertion process, and determining the appropriate container based on the location and context.
 */
let ContainerManager = class ContainerManager {
    insert(proxy, location, elementTypeId, opts) {
        var _a;
        const options = { ...exports.DEFAULT_INSERT_OPTIONS, ...opts };
        const container = this.findContainer(location, proxy, opts === null || opts === void 0 ? void 0 : opts.evt);
        let valid = this.isCreationAllowed(container, elementTypeId, opts);
        if (valid && (!container || options.validateLocationInContainer)) {
            // we need to check whether the location is valid either because we do not have a container or the option is set
            valid = (_a = opts === null || opts === void 0 ? void 0 : opts.validLocationOverwrite) !== null && _a !== void 0 ? _a : this.changeBoundsManager.hasValidPosition(proxy, location);
        }
        return { elementTypeId, container, location, valid, options };
    }
    isCreationAllowed(container, elementTypeId, opts) {
        return !container || container.isContainableElement(elementTypeId);
    }
    findContainer(location, ctx, evt) {
        // reverse order of children to find the innermost, top-rendered containers first
        return [ctx.root, ...(0, sprotty_1.findChildrenAtPosition)(ctx.root, location)]
            .reverse()
            .find(element => { var _a; return (0, model_1.isContainable)(element) && !((_a = element.cssClasses) === null || _a === void 0 ? void 0 : _a.includes(css_feedback_1.CSS_GHOST_ELEMENT)); });
    }
    addInsertFeedback(feedback, trackedInsert, ctx, event) {
        // cursor feedback
        if (!trackedInsert.valid) {
            feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.OPERATION_NOT_ALLOWED), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
        }
        else {
            feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.NODE_CREATION), (0, css_feedback_1.cursorFeedbackAction)());
        }
        return feedback;
    }
};
exports.ContainerManager = ContainerManager;
__decorate([
    (0, inversify_1.inject)(sprotty_1.TYPES.IChangeBoundsManager),
    __metadata("design:type", Object)
], ContainerManager.prototype, "changeBoundsManager", void 0);
exports.ContainerManager = ContainerManager = __decorate([
    (0, inversify_1.injectable)()
], ContainerManager);
//# sourceMappingURL=container-manager.js.map