"use strict";
/********************************************************************************
 * Copyright (c) 2024 Axon Ivy AG and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeBoundsManager = exports.CSS_ACTIVE_HANDLE = exports.CSS_RESTRICTED_RESIZE = exports.CSS_RESIZE_MODE = void 0;
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const css_feedback_1 = require("../../../base/feedback/css-feedback");
const layout_utils_1 = require("../../../utils/layout-utils");
const layout_data_1 = require("../../bounds/layout-data");
const model_1 = require("../../change-bounds/model");
const movement_restrictor_1 = require("../../change-bounds/movement-restrictor");
const insert_indicator_1 = require("../node-creation/insert-indicator");
const change_bounds_tracker_1 = require("./change-bounds-tracker");
exports.CSS_RESIZE_MODE = 'resize-mode';
exports.CSS_RESTRICTED_RESIZE = 'resize-not-allowed';
exports.CSS_ACTIVE_HANDLE = 'active';
/**
 * The default {@link IChangeBoundsManager} implementation. It is responsible for managing
 * the change of bounds for {@link GModelElement}s.
 */
let ChangeBoundsManager = class ChangeBoundsManager {
    constructor(positionTracker, movementRestrictor, snapper, helperLineManager, gridManager) {
        this.positionTracker = positionTracker;
        this.movementRestrictor = movementRestrictor;
        this.snapper = snapper;
        this.helperLineManager = helperLineManager;
        this.gridManager = gridManager;
    }
    unsnapModifier() {
        return 'shift';
    }
    usePositionSnap(arg) {
        return typeof arg === 'boolean' ? arg : !arg.shiftKey;
    }
    snapPosition(element, position) {
        var _a, _b;
        return (_b = (_a = this.snapper) === null || _a === void 0 ? void 0 : _a.snap(position, element)) !== null && _b !== void 0 ? _b : position;
    }
    isValid(element) {
        return this.hasValidPosition(element) && this.hasValidSize(element);
    }
    hasValidPosition(element, position) {
        return !(0, sprotty_1.isLocateable)(element) || (0, layout_utils_1.isValidMove)(element, position !== null && position !== void 0 ? position : element.position, this.movementRestrictor);
    }
    hasValidSize(element, size) {
        if (!(0, sprotty_1.isBoundsAware)(element)) {
            return true;
        }
        const dimension = size !== null && size !== void 0 ? size : element.bounds;
        const minimum = this.getMinimumSize(element);
        if (dimension.width < minimum.width || dimension.height < minimum.height) {
            return false;
        }
        return true;
    }
    getMinimumSize(element) {
        if (!(0, sprotty_1.isBoundsAware)(element)) {
            return sprotty_1.Dimension.EMPTY;
        }
        const definedMinimum = (0, layout_utils_1.minDimensions)(element);
        const computedMinimum = layout_data_1.LayoutAware.getComputedDimensions(element);
        return computedMinimum
            ? {
                width: Math.max(definedMinimum.width, computedMinimum.width),
                height: Math.max(definedMinimum.height, computedMinimum.height)
            }
            : definedMinimum;
    }
    useMovementRestriction(arg) {
        return this.usePositionSnap(arg);
    }
    restrictMovement(element, movement) {
        const minimumMovement = this.getMinimumMovement(element, movement);
        if (!minimumMovement) {
            return movement;
        }
        // minimum is given in absolute coordinates
        // if minimum is not reached, reset to original position for that coordinate
        const absVector = sprotty_1.Vector.abs(movement.vector);
        const targetPosition = {
            x: absVector.x < minimumMovement.x ? movement.from.x : movement.to.x,
            y: absVector.y < minimumMovement.y ? movement.from.y : movement.to.y
        };
        return sprotty_1.Point.move(movement.from, targetPosition);
    }
    getMinimumMovement(element, movement) {
        var _a;
        return element instanceof insert_indicator_1.InsertIndicator && this.gridManager
            ? this.gridManager.grid
            : (_a = this.helperLineManager) === null || _a === void 0 ? void 0 : _a.getMinimumMoveVector(element, true, movement.direction);
    }
    addMoveFeedback(feedback, trackedMove, ctx, event) {
        // cursor feedback on graph
        feedback.add((0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.MOVE), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
        // restriction feedback on each element
        trackedMove.elementMoves.forEach(move => this.addMoveRestrictionFeedback(feedback, move, ctx, event));
        return feedback;
    }
    addResizeFeedback(feedback, resize, ctx, event) {
        // graph feedback
        feedback.add(css_feedback_1.ModifyCSSFeedbackAction.create({ add: [exports.CSS_RESIZE_MODE] }), css_feedback_1.ModifyCSSFeedbackAction.create({ remove: [exports.CSS_RESIZE_MODE] }));
        // cursor feedback on graph
        const cursorClass = model_1.GResizeHandle.getCursorCss(resize.handleMove.element);
        feedback.add((0, css_feedback_1.cursorFeedbackAction)(cursorClass), (0, css_feedback_1.cursorFeedbackAction)(css_feedback_1.CursorCSS.DEFAULT));
        // handle feedback
        const handle = resize.handleMove.element;
        feedback.add((0, css_feedback_1.applyCssClasses)(handle, exports.CSS_ACTIVE_HANDLE), (0, css_feedback_1.deleteCssClasses)(handle, exports.CSS_ACTIVE_HANDLE));
        feedback.add((0, css_feedback_1.toggleCssClasses)(handle, !resize.valid.size, exports.CSS_RESTRICTED_RESIZE), (0, css_feedback_1.deleteCssClasses)(handle, exports.CSS_RESTRICTED_RESIZE));
        // restriction feedback on each element
        resize.elementResizes.forEach(elementResize => {
            this.addMoveRestrictionFeedback(feedback, elementResize, ctx, event);
            feedback.add((0, css_feedback_1.toggleCssClasses)(elementResize.element, !elementResize.valid.size, exports.CSS_RESTRICTED_RESIZE), (0, css_feedback_1.deleteCssClasses)(elementResize.element, exports.CSS_RESTRICTED_RESIZE));
        });
        return feedback;
    }
    addMoveRestrictionFeedback(feedback, change, ctx, event) {
        if (this.movementRestrictor) {
            const valid = change_bounds_tracker_1.TrackedElementMove.is(change) ? change.valid : change.valid.move;
            feedback.add((0, movement_restrictor_1.movementRestrictionFeedback)(change.element, this.movementRestrictor, valid), (0, movement_restrictor_1.removeMovementRestrictionFeedback)(change.element, this.movementRestrictor));
        }
        return feedback;
    }
    defaultResizeLocations() {
        return model_1.ResizeHandleLocation.CORNERS;
    }
    useSymmetricResize(arg) {
        return typeof arg === 'boolean' ? arg : arg.ctrlKey;
    }
    createTracker() {
        return new change_bounds_tracker_1.ChangeBoundsTracker(this);
    }
};
exports.ChangeBoundsManager = ChangeBoundsManager;
exports.ChangeBoundsManager = ChangeBoundsManager = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.MousePositionTracker)),
    __param(1, (0, inversify_1.optional)()),
    __param(1, (0, inversify_1.inject)(sprotty_1.TYPES.IMovementRestrictor)),
    __param(2, (0, inversify_1.optional)()),
    __param(2, (0, inversify_1.inject)(sprotty_1.TYPES.ISnapper)),
    __param(3, (0, inversify_1.optional)()),
    __param(3, (0, inversify_1.inject)(sprotty_1.TYPES.IHelperLineManager)),
    __param(4, (0, inversify_1.optional)()),
    __param(4, (0, inversify_1.inject)(sprotty_1.TYPES.IGridManager)),
    __metadata("design:paramtypes", [sprotty_1.MousePositionTracker, Object, Object, Object, Object])
], ChangeBoundsManager);
//# sourceMappingURL=change-bounds-manager.js.map