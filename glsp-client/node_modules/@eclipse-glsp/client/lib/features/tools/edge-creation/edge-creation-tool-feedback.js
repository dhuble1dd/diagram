"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedbackEdgeEndMovingMouseListener = void 0;
/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const viewpoint_util_1 = require("../../../utils/viewpoint-util");
const dangling_edge_feedback_1 = require("./dangling-edge-feedback");
class FeedbackEdgeEndMovingMouseListener extends sprotty_1.MouseListener {
    constructor(anchorRegistry, feedbackDispatcher) {
        super();
        this.anchorRegistry = anchorRegistry;
        this.feedbackDispatcher = feedbackDispatcher;
        this.feedback = feedbackDispatcher.createEmitter();
    }
    mouseMove(target, event) {
        const root = target.root;
        const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
        if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
        }
        const edge = edgeEnd.feedbackEdge;
        const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
        const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position)
            .reverse()
            .find(element => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, 'target'));
        if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.source && (0, sprotty_1.isBoundsAware)(edge.source)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center((0, viewpoint_util_1.toAbsoluteBounds)(edge.source)));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
                this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })).submit();
            }
        }
        else {
            this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })).submit();
        }
        return [];
    }
    computeAbsoluteAnchor(element, absoluteReferencePoint, offset) {
        const referencePointInParent = (0, viewpoint_util_1.absoluteToParent)(element, absoluteReferencePoint);
        const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
        let anchor = anchorComputer.getAnchor(element, referencePointInParent, offset);
        // The anchor is computed in the local coordinate system of the element.
        // If the element is a nested child element we have to add the absolute position of its parent to the anchor.
        if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
                const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
                anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
        }
        return anchor;
    }
    dispose() {
        this.feedback.dispose();
    }
}
exports.FeedbackEdgeEndMovingMouseListener = FeedbackEdgeEndMovingMouseListener;
//# sourceMappingURL=edge-creation-tool-feedback.js.map