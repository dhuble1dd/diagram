"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultFeedbackEdgeSchema = exports.FeedbackEdgeEnd = exports.RemoveFeedbackEdgeCommand = exports.RemoveFeedbackEdgeAction = exports.DrawFeedbackEdgeCommand = exports.DrawFeedbackEdgeAction = void 0;
exports.feedbackEdgeId = feedbackEdgeId;
exports.feedbackEdgeEndId = feedbackEdgeEndId;
exports.drawFeedbackEdge = drawFeedbackEdge;
exports.removeDanglingFeedbackEdge = removeDanglingFeedbackEdge;
exports.configureDanglingFeedbackEdge = configureDanglingFeedbackEdge;
/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const feedback_action_dispatcher_1 = require("../../../base/feedback/feedback-action-dispatcher");
const feedback_command_1 = require("../../../base/feedback/feedback-command");
const gmodel_util_1 = require("../../../utils/gmodel-util");
const viewpoint_util_1 = require("../../../utils/viewpoint-util");
const view_1 = require("./view");
var DrawFeedbackEdgeAction;
(function (DrawFeedbackEdgeAction) {
    DrawFeedbackEdgeAction.KIND = 'drawFeedbackEdge';
    function is(object) {
        return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeAction.KIND);
    }
    DrawFeedbackEdgeAction.is = is;
    function create(options) {
        return {
            kind: DrawFeedbackEdgeAction.KIND,
            ...options
        };
    }
    DrawFeedbackEdgeAction.create = create;
})(DrawFeedbackEdgeAction || (exports.DrawFeedbackEdgeAction = DrawFeedbackEdgeAction = {}));
let DrawFeedbackEdgeCommand = class DrawFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        drawFeedbackEdge(context, this.action.sourceId, this.action.elementTypeId, this.action.edgeSchema);
        return context.root;
    }
};
exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand;
DrawFeedbackEdgeCommand.KIND = DrawFeedbackEdgeAction.KIND;
exports.DrawFeedbackEdgeCommand = DrawFeedbackEdgeCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], DrawFeedbackEdgeCommand);
var RemoveFeedbackEdgeAction;
(function (RemoveFeedbackEdgeAction) {
    RemoveFeedbackEdgeAction.KIND = 'removeFeedbackEdgeCommand';
    function is(object) {
        return sprotty_1.Action.hasKind(object, RemoveFeedbackEdgeAction.KIND);
    }
    RemoveFeedbackEdgeAction.is = is;
    function create() {
        return { kind: RemoveFeedbackEdgeAction.KIND };
    }
    RemoveFeedbackEdgeAction.create = create;
})(RemoveFeedbackEdgeAction || (exports.RemoveFeedbackEdgeAction = RemoveFeedbackEdgeAction = {}));
let RemoveFeedbackEdgeCommand = class RemoveFeedbackEdgeCommand extends feedback_command_1.FeedbackCommand {
    execute(context) {
        removeDanglingFeedbackEdge(context.root);
        return context.root;
    }
};
exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand;
RemoveFeedbackEdgeCommand.KIND = RemoveFeedbackEdgeAction.KIND;
exports.RemoveFeedbackEdgeCommand = RemoveFeedbackEdgeCommand = __decorate([
    (0, inversify_1.injectable)()
], RemoveFeedbackEdgeCommand);
class FeedbackEdgeEnd extends sprotty_1.GDanglingAnchor {
    constructor(sourceId, elementTypeId, feedbackEdge = undefined, type = FeedbackEdgeEnd.TYPE) {
        super();
        this.sourceId = sourceId;
        this.elementTypeId = elementTypeId;
        this.feedbackEdge = feedbackEdge;
        this.type = type;
    }
}
exports.FeedbackEdgeEnd = FeedbackEdgeEnd;
FeedbackEdgeEnd.DEFAULT_FEATURES = [sprotty_1.deletableFeature, feedback_action_dispatcher_1.feedbackFeature];
FeedbackEdgeEnd.TYPE = 'feedback-edge-end';
function feedbackEdgeId(root) {
    return root.id + '_feedback_edge';
}
function feedbackEdgeEndId(root) {
    return root.id + '_feedback_anchor';
}
exports.defaultFeedbackEdgeSchema = {
    cssClasses: ['feedback-edge'],
    opacity: 0.3
};
function drawFeedbackEdge(context, sourceId, elementTypeId, edgeTemplate) {
    const root = context.root;
    const sourceChild = root.index.getById(sourceId);
    if (!sourceChild) {
        return;
    }
    const source = (0, sprotty_1.findParentByFeature)(sourceChild, sprotty_1.isConnectable);
    if (!source || !(0, sprotty_1.isBoundsAware)(source)) {
        return;
    }
    const edgeEnd = new FeedbackEdgeEnd(source.id, elementTypeId);
    edgeEnd.id = feedbackEdgeEndId(root);
    edgeEnd.position = (0, viewpoint_util_1.toAbsolutePosition)(source);
    const edgeSchema = {
        id: feedbackEdgeId(root),
        type: elementTypeId,
        sourceId: source.id,
        targetId: edgeEnd.id,
        ...exports.defaultFeedbackEdgeSchema,
        ...edgeTemplate
    };
    const feedbackEdge = context.modelFactory.createElement(edgeSchema);
    if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
        edgeEnd.feedbackEdge = feedbackEdge;
        root.add(edgeEnd);
        root.add(feedbackEdge);
    }
}
function removeDanglingFeedbackEdge(root) {
    const feedbackEdge = root.index.getById(feedbackEdgeId(root));
    const feedbackEdgeEnd = root.index.getById(feedbackEdgeEndId(root));
    if (feedbackEdge instanceof sprotty_1.GChildElement) {
        root.remove(feedbackEdge);
    }
    if (feedbackEdgeEnd instanceof sprotty_1.GChildElement) {
        root.remove(feedbackEdgeEnd);
    }
}
function configureDanglingFeedbackEdge(context) {
    if (!context.isBound(DrawFeedbackEdgeCommand) && !context.isBound(RemoveFeedbackEdgeCommand) && !context.isBound(view_1.FeedbackEdgeEndView)) {
        (0, sprotty_1.configureCommand)(context, DrawFeedbackEdgeCommand);
        (0, sprotty_1.configureCommand)(context, RemoveFeedbackEdgeCommand);
        (0, sprotty_1.configureView)(context, FeedbackEdgeEnd.TYPE, view_1.FeedbackEdgeEndView);
    }
}
//# sourceMappingURL=dangling-edge-feedback.js.map