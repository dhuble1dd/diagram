"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedbackEdgeRouteMovingMouseListener = exports.FeedbackEdgeSourceMovingMouseListener = exports.FeedbackEdgeTargetMovingMouseListener = exports.DrawFeedbackEdgeSourceCommand = exports.DrawFeedbackEdgeSourceAction = exports.SwitchRoutingModeCommand = exports.SwitchRoutingModeAction = exports.HideEdgeReconnectHandlesFeedbackCommand = exports.ShowEdgeReconnectHandlesFeedbackCommand = exports.HideEdgeReconnectHandlesFeedbackAction = exports.ShowEdgeReconnectHandlesFeedbackAction = void 0;
exports.drawFeedbackEdgeSource = drawFeedbackEdgeSource;
/********************************************************************************
 * Copyright (c) 2019-2024 EclipseSource and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
const sprotty_1 = require("@eclipse-glsp/sprotty");
const inversify_1 = require("inversify");
const drag_aware_mouse_listener_1 = require("../../../base/drag-aware-mouse-listener");
const feedback_command_1 = require("../../../base/feedback/feedback-command");
const gmodel_util_1 = require("../../../utils/gmodel-util");
const viewpoint_util_1 = require("../../../utils/viewpoint-util");
const model_1 = require("../../reconnect/model");
const change_bounds_tracker_1 = require("../change-bounds/change-bounds-tracker");
const dangling_edge_feedback_1 = require("../edge-creation/dangling-edge-feedback");
const edge_creation_tool_feedback_1 = require("../edge-creation/edge-creation-tool-feedback");
var ShowEdgeReconnectHandlesFeedbackAction;
(function (ShowEdgeReconnectHandlesFeedbackAction) {
    ShowEdgeReconnectHandlesFeedbackAction.KIND = 'showReconnectHandlesFeedback';
    function is(object) {
        return sprotty_1.Action.hasKind(object, ShowEdgeReconnectHandlesFeedbackAction.KIND);
    }
    ShowEdgeReconnectHandlesFeedbackAction.is = is;
    function create(elementId) {
        return { kind: ShowEdgeReconnectHandlesFeedbackAction.KIND, elementId };
    }
    ShowEdgeReconnectHandlesFeedbackAction.create = create;
})(ShowEdgeReconnectHandlesFeedbackAction || (exports.ShowEdgeReconnectHandlesFeedbackAction = ShowEdgeReconnectHandlesFeedbackAction = {}));
var HideEdgeReconnectHandlesFeedbackAction;
(function (HideEdgeReconnectHandlesFeedbackAction) {
    HideEdgeReconnectHandlesFeedbackAction.KIND = 'hideReconnectHandlesFeedback';
    function is(object) {
        return sprotty_1.Action.hasKind(object, HideEdgeReconnectHandlesFeedbackAction.KIND);
    }
    HideEdgeReconnectHandlesFeedbackAction.is = is;
    function create() {
        return { kind: HideEdgeReconnectHandlesFeedbackAction.KIND };
    }
    HideEdgeReconnectHandlesFeedbackAction.create = create;
})(HideEdgeReconnectHandlesFeedbackAction || (exports.HideEdgeReconnectHandlesFeedbackAction = HideEdgeReconnectHandlesFeedbackAction = {}));
let ShowEdgeReconnectHandlesFeedbackCommand = class ShowEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        const index = context.root.index;
        (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
        const routableElement = index.getById(this.action.elementId);
        if (routableElement && (0, gmodel_util_1.isRoutable)(routableElement)) {
            (0, model_1.addReconnectHandles)(routableElement);
        }
        return context.root;
    }
};
exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand;
ShowEdgeReconnectHandlesFeedbackCommand.KIND = ShowEdgeReconnectHandlesFeedbackAction.KIND;
exports.ShowEdgeReconnectHandlesFeedbackCommand = ShowEdgeReconnectHandlesFeedbackCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], ShowEdgeReconnectHandlesFeedbackCommand);
let HideEdgeReconnectHandlesFeedbackCommand = class HideEdgeReconnectHandlesFeedbackCommand extends feedback_command_1.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        const index = context.root.index;
        (0, gmodel_util_1.forEachElement)(index, gmodel_util_1.isRoutable, model_1.removeReconnectHandles);
        return context.root;
    }
};
exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand;
HideEdgeReconnectHandlesFeedbackCommand.KIND = HideEdgeReconnectHandlesFeedbackAction.KIND;
exports.HideEdgeReconnectHandlesFeedbackCommand = HideEdgeReconnectHandlesFeedbackCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], HideEdgeReconnectHandlesFeedbackCommand);
var SwitchRoutingModeAction;
(function (SwitchRoutingModeAction) {
    SwitchRoutingModeAction.KIND = 'switchRoutingMode';
    function create(options) {
        return {
            ...sprotty_1.SwitchEditModeAction.create(options),
            kind: SwitchRoutingModeAction.KIND
        };
    }
    SwitchRoutingModeAction.create = create;
})(SwitchRoutingModeAction || (exports.SwitchRoutingModeAction = SwitchRoutingModeAction = {}));
let SwitchRoutingModeCommand = class SwitchRoutingModeCommand extends sprotty_1.SwitchEditModeCommand {
    constructor(action) {
        super({ ...action, kind: sprotty_1.SwitchEditModeAction.KIND });
    }
};
exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand;
SwitchRoutingModeCommand.KIND = SwitchRoutingModeAction.KIND;
exports.SwitchRoutingModeCommand = SwitchRoutingModeCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], SwitchRoutingModeCommand);
var DrawFeedbackEdgeSourceAction;
(function (DrawFeedbackEdgeSourceAction) {
    DrawFeedbackEdgeSourceAction.KIND = 'drawFeedbackEdgeSource';
    function is(object) {
        return sprotty_1.Action.hasKind(object, DrawFeedbackEdgeSourceAction.KIND) && (0, sprotty_1.hasStringProp)(object, 'elementTypeId') && (0, sprotty_1.hasStringProp)(object, 'targetId');
    }
    DrawFeedbackEdgeSourceAction.is = is;
    function create(options) {
        return {
            kind: DrawFeedbackEdgeSourceAction.KIND,
            ...options
        };
    }
    DrawFeedbackEdgeSourceAction.create = create;
})(DrawFeedbackEdgeSourceAction || (exports.DrawFeedbackEdgeSourceAction = DrawFeedbackEdgeSourceAction = {}));
let DrawFeedbackEdgeSourceCommand = class DrawFeedbackEdgeSourceCommand extends feedback_command_1.FeedbackCommand {
    constructor(action) {
        super();
        this.action = action;
    }
    execute(context) {
        drawFeedbackEdgeSource(context, this.action.targetId, this.action.elementTypeId);
        return context.root;
    }
};
exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand;
DrawFeedbackEdgeSourceCommand.KIND = DrawFeedbackEdgeSourceAction.KIND;
exports.DrawFeedbackEdgeSourceCommand = DrawFeedbackEdgeSourceCommand = __decorate([
    (0, inversify_1.injectable)(),
    __param(0, (0, inversify_1.inject)(sprotty_1.TYPES.Action)),
    __metadata("design:paramtypes", [Object])
], DrawFeedbackEdgeSourceCommand);
/**
 * SOURCE AND TARGET MOUSE MOVE LISTENER
 */
class FeedbackEdgeTargetMovingMouseListener extends edge_creation_tool_feedback_1.FeedbackEdgeEndMovingMouseListener {
    constructor(anchorRegistry, feedbackDispatcher) {
        super(anchorRegistry, feedbackDispatcher);
    }
}
exports.FeedbackEdgeTargetMovingMouseListener = FeedbackEdgeTargetMovingMouseListener;
class FeedbackEdgeSourceMovingMouseListener extends sprotty_1.MouseListener {
    constructor(anchorRegistry, feedbackDispatcher) {
        super();
        this.anchorRegistry = anchorRegistry;
        this.feedbackDispatcher = feedbackDispatcher;
        this.feedback = feedbackDispatcher.createEmitter();
    }
    mouseMove(target, event) {
        const root = target.root;
        const edgeEnd = root.index.getById((0, dangling_edge_feedback_1.feedbackEdgeEndId)(root));
        if (!(edgeEnd instanceof dangling_edge_feedback_1.FeedbackEdgeEnd) || !edgeEnd.feedbackEdge) {
            return [];
        }
        const edge = edgeEnd.feedbackEdge;
        const position = (0, viewpoint_util_1.getAbsolutePosition)(edgeEnd, event);
        const endAtMousePosition = (0, sprotty_1.findChildrenAtPosition)(target.root, position).find(element => (0, sprotty_1.isConnectable)(element) && element.canConnect(edge, 'source'));
        if (endAtMousePosition instanceof sprotty_1.GConnectableElement && edge.target && (0, sprotty_1.isBoundsAware)(edge.target)) {
            const anchor = this.computeAbsoluteAnchor(endAtMousePosition, sprotty_1.Bounds.center(edge.target.bounds));
            if (sprotty_1.Point.euclideanDistance(anchor, edgeEnd.position) > 1) {
                this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: anchor }], { animate: false })).submit();
            }
        }
        else {
            this.feedback.add(sprotty_1.MoveAction.create([{ elementId: edgeEnd.id, toPosition: position }], { animate: false })).submit();
        }
        return [];
    }
    computeAbsoluteAnchor(element, referencePoint, offset) {
        const anchorComputer = this.anchorRegistry.get(sprotty_1.PolylineEdgeRouter.KIND, element.anchorKind);
        let anchor = anchorComputer.getAnchor(element, referencePoint, offset);
        // The anchor is computed in the local coordinate system of the element.
        // If the element is a nested child element we have to add the absolute position of its parent to the anchor.
        if (element.parent !== element.root) {
            const parent = (0, sprotty_1.findParentByFeature)(element.parent, sprotty_1.isBoundsAware);
            if (parent) {
                const absoluteParentPosition = (0, viewpoint_util_1.toAbsoluteBounds)(parent);
                anchor = sprotty_1.Point.add(absoluteParentPosition, anchor);
            }
        }
        return anchor;
    }
    dispose() {
        this.feedback.dispose();
    }
}
exports.FeedbackEdgeSourceMovingMouseListener = FeedbackEdgeSourceMovingMouseListener;
class FeedbackEdgeRouteMovingMouseListener extends drag_aware_mouse_listener_1.DragAwareMouseListener {
    constructor(changeBoundsManager, edgeRouterRegistry) {
        super();
        this.changeBoundsManager = changeBoundsManager;
        this.edgeRouterRegistry = edgeRouterRegistry;
        this.tracker = this.changeBoundsManager.createTracker();
    }
    mouseDown(target, event) {
        const result = super.mouseDown(target, event);
        if (event.button === 0) {
            const routingHandle = (0, sprotty_1.findParentByFeature)(target, gmodel_util_1.isRoutingHandle);
            if (routingHandle !== undefined) {
                result.push(SwitchRoutingModeAction.create({ elementsToActivate: [target.id] }));
                this.tracker.startTracking();
            }
            else {
                this.tracker.dispose();
            }
        }
        return result;
    }
    draggingMouseMove(target, event) {
        super.draggingMouseMove(target, event);
        if (this.tracker.isTracking()) {
            return this.moveRoutingHandles(target, event);
        }
        return [];
    }
    moveRoutingHandles(target, event) {
        const routingHandlesToMove = this.getRoutingHandlesToMove(target);
        const move = this.tracker.moveElements(routingHandlesToMove, { snap: event, restrict: event });
        if (move.elementMoves.length === 0) {
            return [];
        }
        this.tracker.updateTrackingPosition(move);
        return [
            sprotty_1.MoveAction.create(move.elementMoves.map(elementMove => ({ elementId: elementMove.element.id, toPosition: elementMove.toPosition })), { animate: false })
        ];
    }
    getRoutingHandlesToMove(context) {
        const selectedRoutingHandles = (0, gmodel_util_1.getMatchingElements)(context.root.index, (0, sprotty_1.typeGuard)(gmodel_util_1.isRoutingHandle, sprotty_1.isSelected));
        return selectedRoutingHandles
            .map(handle => {
            const position = this.getHandlePosition(handle);
            return position ? new change_bounds_tracker_1.MoveableRoutingHandle(handle, position) : undefined;
        })
            .filter((0, sprotty_1.toTypeGuard)(change_bounds_tracker_1.MoveableRoutingHandle));
    }
    getHandlePosition(handle) {
        if (this.edgeRouterRegistry) {
            const parent = handle.parent;
            if (!(0, gmodel_util_1.isRoutable)(parent)) {
                return undefined;
            }
            const router = this.edgeRouterRegistry.get(parent.routerKind);
            const route = router.route(parent);
            return router.getHandlePosition(parent, route, handle);
        }
        return undefined;
    }
    nonDraggingMouseUp(element, event) {
        // should reset everything that may have happend on mouse down
        this.tracker.stopTracking();
        return [];
    }
    draggingMouseUp(_target, _event) {
        if (!this.tracker.isTracking()) {
            return [];
        }
        this.dispose();
        return [];
    }
    dispose() {
        this.tracker.dispose();
        super.dispose();
    }
}
exports.FeedbackEdgeRouteMovingMouseListener = FeedbackEdgeRouteMovingMouseListener;
/**
 * UTILITY FUNCTIONS
 */
function drawFeedbackEdgeSource(context, targetId, elementTypeId) {
    const root = context.root;
    const targetChild = root.index.getById(targetId);
    if (!targetChild) {
        return;
    }
    const target = (0, sprotty_1.findParentByFeature)(targetChild, sprotty_1.isConnectable);
    if (!target || !(0, sprotty_1.isBoundsAware)(target)) {
        return;
    }
    const edgeEnd = new dangling_edge_feedback_1.FeedbackEdgeEnd(target.id, elementTypeId);
    edgeEnd.id = (0, dangling_edge_feedback_1.feedbackEdgeEndId)(root);
    edgeEnd.position = { x: target.bounds.x, y: target.bounds.y };
    const feedbackEdgeSchema = {
        type: 'edge',
        id: (0, dangling_edge_feedback_1.feedbackEdgeId)(root),
        sourceId: edgeEnd.id,
        targetId: target.id,
        opacity: 0.3
    };
    const feedbackEdge = context.modelFactory.createElement(feedbackEdgeSchema);
    if ((0, gmodel_util_1.isRoutable)(feedbackEdge)) {
        edgeEnd.feedbackEdge = feedbackEdge;
        root.add(edgeEnd);
        root.add(feedbackEdge);
    }
}
//# sourceMappingURL=edge-edit-tool-feedback.js.map